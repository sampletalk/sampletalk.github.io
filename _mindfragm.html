<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE>SampleX </TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice 4.1.11  (Win32)">
	<META NAME="AUTHOR" CONTENT="Andrew">
	<META NAME="CREATED" CONTENT="20010717;20050000">
	<META NAME="CHANGEDBY" CONTENT="----------">
	<META NAME="CHANGED" CONTENT="20120102;21050000">
	<STYLE TYPE="text/css">
	<!--
		@page { margin-right: 0.59in; margin-top: 0.79in; margin-bottom: 0.49in }
		P { margin-bottom: 0in; text-align: justify }
		P.western { font-family: "Dutch", "Times New Roman", serif; font-size: 12pt; so-language: en-US }
		P.cjk { font-family: "Dutch", "Times New Roman", serif; font-size: 12pt; so-language: en-US }
		P.ctl { font-family: "Dutch", "Times New Roman", serif; font-size: 12pt; so-language: he-IL }
		A:link { color: #0000ff; font-family: "Times New Roman", serif }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-US" LINK="#0000ff" DIR="LTR" STYLE="border: none; padding: 0in">
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in"><FONT COLOR="#ff00ff">This
is an English translation of paper /18/ (see below) </FONT>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in"><BR>
</P>
<P ALIGN=LEFT><A NAME="_Toc467515547"></A><FONT FACE="Switzerland, Arial, sans-serif"><FONT SIZE=6 STYLE="font-size: 28pt"><B>Text
Example Generalization: Synthesis of Sampletalk Programs </B></FONT></FONT>
</P>
<P ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><FONT SIZE=4 STYLE="font-size: 16pt"><B>Andrew Gleibman
</B></FONT>
</P>
<P ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT STYLE="margin-bottom: 0.04in; page-break-after: avoid"><BR><BR>
</P>
<P ALIGN=LEFT STYLE="margin-bottom: 0.04in; page-break-after: avoid"><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5><I><B>Abstract</B></I></FONT></FONT></P>
<P CLASS="western">	</P>
<P CLASS="western" STYLE="text-indent: 0.5in"><I>In this paper, a
technique for automatic and semi-automatic synthesis of text
processing programs is introduced. Processing rules are defined by
demo samples of text transformations. A synthesizer discovers and
generalizes regularities, presented by the user in form of text
examples, and applies them in order to create an algorithm for
processing of a more wide class of texts.</I></P>
<P CLASS="western" ALIGN=JUSTIFY><I>	Sampletalk Language serves for
implementation of the synthesized algorithms. As a programming
language, Sampletalk provides a programming technology based on text
abstraction.</I></P>
<P CLASS="western" ALIGN=JUSTIFY><I>	The following program examples
are considered: transformation of arithmetical and logical
expressions, description of a technical assembly, natural language
reasoning, word and list inversion, replacing word occurrences in
expressions etc. Some program examples demonstrate reasoning, hardly
attainable using other programming technologies.</I></P>
<P><I>	In a theoretical consideration, it is proven that Sampletalk
is Turing-complete language and that for any Sampletalk program some
equivalent program can be automatically constructed by applying the
proposed technique of synthesis to a suitable set of text samples.
This technique provides an alternative way of programming, in which
the user, instead of writing a program code, trains a program
synthesizer by successive text examples of incrementing complexity
and detalization.</I></P>
<P ALIGN=JUSTIFY STYLE="text-indent: 0.5in"><I>Using introduced here
generalization, structurization and composition of text examples, we
can build any algorithm. So, we speak of programming by having
computer to define object combination and to combine existing objects
into new ones automatically. The question how to lead this process to
useful combinations is considered.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="page-break-before: always"><BR>
</P>
<OL>
	<LI><P ALIGN=LEFT><A NAME="_Toc467515548"></A><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5 STYLE="font-size: 20pt"><B>Introduction</B></FONT></FONT></P>
</OL>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>The main paradigm, which is
described in this work, can be formulated as <I><B>synthesis of
algorithms basing on human or another object behavior examples,</B></I>
without any a-priori knowledge but some universal one. This paradigm
has been investigated and represented in literature for various kinds
of algorithms, intelligent structures, representations of behavior of
investigated objects, and basic knowledge. Table 1.1 contains
examples of such research; the last line in the table represents the
present work.</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<TABLE WIDTH=590 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=133>
	<COL WIDTH=134>
	<COL WIDTH=134>
	<COL WIDTH=133>
	<TR VALIGN=TOP>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT><I><B>Object behavior information</B></I></P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT><I><B>Kind of synthesized structures</B></I></P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT><I><B>Universal knowledge</B></I></P>
		</TD>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT><I><B>Reference</B></I></P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Chemical descriptions</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Chemical compound</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Logical calculus, properties of
			numbers</P>
		</TD>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Langley et al. /30/</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Physical Observations</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Physical law</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Heuristics about numbers,
			programming language</P>
		</TD>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Falkenhainer, Michalsky /12/</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Mathematical definitions</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Mathematical theory</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Mathematical heuristics</P>
		</TD>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Lenat /31/</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Sample calculations, algorithm
			history</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Program 
			</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Arithmetic properties, programming
			language</P>
		</TD>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Barsdin et al.</P>
			<P CLASS="western" ALIGN=LEFT>/4/,/5/,/28,29/</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Physical laws, observations</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Simultaneous equations</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Logical calculus and model</P>
		</TD>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Gleibman /20,21/; 
			</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Text transformations</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Program</P>
		</TD>
		<TD WIDTH=134>
			<P CLASS="western" ALIGN=LEFT>Text matching, Logic programming
			language</P>
		</TD>
		<TD WIDTH=133>
			<P CLASS="western" ALIGN=LEFT>Gleibman /15,16/; 
			</P>
			<P CLASS="western" ALIGN=LEFT><I>this paper</I></P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Table 1.1. Universal Knowledge and
the Paradigm of Synthesis</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Constructions related to the second
column of this table represent generalization of constructions from
the first column. Rules of generalization are represented in the
third column.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Generation of programs sometimes is
made using combination and transformation of descriptions of an
algorithm or an environment (program language source code, formal
program specification, description of an artificial world etc).
Attempts to recognize regularities in algorithm history or to build
formal description of algorithm performance are made (see our review
in Section 4). The source of the formal description is usually
assumed to be a human. Sometimes sophisticated syntax and semantic
rules are justly or unjustly involved in them.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Note that a-priori syntax and
semantic rules of a sophisticated programming language usually are
not similar to thinking of an individual programmer and often hinder
him from a natural (for him) way of formulating algorithms. On the
other hand, he usually may easily formulate his own rules or informal
hypotheses about the algorithm being devised basing on examples of
data being processed, or, what is more important for us, formulate
data samples basing on hypotheses about the algorithm. Examples of
such samples and hypotheses are given in Table 1.2.</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><BR>
</P>
<TABLE WIDTH=590 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=280>
	<COL WIDTH=280>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><I><B>Sample</B></I></P>
		</TD>
		<TD WIDTH=280>
			<P ALIGN=LEFT><I><B>Possible hypotheses</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><B>ab =&gt; ba</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Inversion of all word preceding &quot;<B>=&gt;</B>&quot;</P>
			<P CLASS="western" ALIGN=LEFT>Swap two adjacent sub-words</P>
			<P CLASS="western" ALIGN=LEFT>Swap something with letter <B>b</B></P>
			<P ALIGN=LEFT>... (other hypotheses)</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><B>abc =&gt; cba</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Inversion of all word preceding &quot;<B>=&gt;</B>&quot;</P>
			<P ALIGN=LEFT>...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><B>(y/x)axb = ayb</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Replace all occurrences of <B>x</B>
			by <B>y</B></P>
			<P CLASS="western" ALIGN=LEFT>Replace only the first such
			occurrence</P>
			<P CLASS="western" ALIGN=LEFT>Replace something with word <B>ayb</B></P>
			<P ALIGN=LEFT>...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><B>(y/x)axbxc = aybyc</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Replace all occurrences of <B>x</B>
			by <B>y</B></P>
			<P ALIGN=LEFT>...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><B>axbcd -&gt; abxcd</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Shift <B>x</B> one position right</P>
			<P CLASS="western" ALIGN=LEFT>Swap <B>x</B> with its left or right
			neighbor</P>
			<P ALIGN=LEFT>...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><B>axbcd -&gt; xabcd</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Shift <B>x</B> to the beginning of a
			word</P>
			<P CLASS="western" ALIGN=LEFT>Swap <B>x</B> with its left or right
			neighbor</P>
			<P ALIGN=LEFT>...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P ALIGN=LEFT><B>Polish(a+b) is +ab</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Swap <B>a</B> and <B>+</B> and
			eliminate parentheses</P>
			<P CLASS="western" ALIGN=LEFT>Translate an expression into Polish
			notation</P>
			<P ALIGN=LEFT>&hellip;</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT><B>Where is a tree? In the forest.</B></P>
			<P CLASS="western" ALIGN=LEFT><B>Where is a fish? In the sea.</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>A definition for location of some
			object</P>
			<P CLASS="western" ALIGN=LEFT>and reasoning about this location</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT><B>New York is situated in America.</B></P>
			<P CLASS="western" ALIGN=LEFT><B>Where is New York? In America.</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>The similar definition and reasoning</P>
			<P CLASS="western" ALIGN=LEFT>about location of another object</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT><B>x</B><SUB><B>0</B></SUB><B> is
			variable</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Something is a notation of a
			variable</P>
			<P CLASS="western" ALIGN=LEFT>Something includes number 0</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT><B>x</B><SUB><B>10</B></SUB><B> is
			variable</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Something is a notation of a
			variable</P>
			<P CLASS="western" ALIGN=LEFT>...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT><B>(forall x</B><SUB><B>0</B></SUB><B>)a
			or (forall x</B><SUB><B>0</B></SUB><B>)b--&gt; </B>
			</P>
			<P CLASS="western" ALIGN=LEFT><B>(forall x</B><SUB><B>0</B></SUB><B>)(forall
			x</B><SUB><B>0</B></SUB><B>)(a or b)</B>	</P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Shift quantifiers into the formula
			prefix</P>
			<P CLASS="western" ALIGN=LEFT>Move the second <B>(forall x</B><SUB><B>0</B></SUB><B>)</B>
			to the left</P>
			<P CLASS="western" ALIGN=LEFT>...</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT><B>forall x</B><SUB><B>0</B></SUB><B>)a(x</B><SUB><B>0</B></SUB><B>,y)
			or (forall x</B><SUB><B>0</B></SUB><B>)b(x</B><SUB><B>0</B></SUB><B>,t)--&gt;</B></P>
			<P CLASS="western" ALIGN=LEFT><B>(forall x</B><SUB><B>0</B></SUB><B>)(forall
			x</B><SUB><B>10</B></SUB><B>)(a(x</B><SUB><B>0</B></SUB><B>,y) or
			b(x</B><SUB><B>10</B></SUB><B>,t))</B></P>
		</TD>
		<TD WIDTH=280>
			<P CLASS="western" ALIGN=LEFT>Shift quantifiers into the formula
			prefix</P>
			<P CLASS="western" ALIGN=LEFT>&hellip;</P>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=2 WIDTH=574 VALIGN=TOP>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Table 1.2. Text examples and
informal hypotheses about them</B></P>
<P ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Our question is <I>how can such
hypotheses be automatically formulated in a more formal way</I>, so
that a useful text-processing program could be automatically
constructed from them.</P>
<P CLASS="western" ALIGN=JUSTIFY>	This problem is typical for Machine
Learning: we can consider it as an attempt to automatically improve
performance or another characteristic of an artificial system via
discovery of useful information from the world, which is here
represented in texts. 
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">Consider
the following characteristics of Machine Learning systems: 1) kind of
the external world for the system (physical motions, chemical
reactions, historic events, arbitrary data expressed in texts as in
this chapter, etc); 2) discovery component, which forms hypotheses
about the observed events; 3) evaluating function for filtering
useful hypotheses from other hypotheses.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Assume that a human can obtain
texts, which represent the external world. He wants to create a
program and is able to provide the discovery system with desired data
processing examples. Assume also that he has a possibility to
evaluate newly created programs against the initial examples and
against other examples. So, we are concentrated in a discovery
component for program synthesis.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Our preceding note about thinking
of an individual programmer prevents us from considering any
sophisticated computer programming language as a universal knowledge
for text processing. More likely, an ability to recognize and apply
regularities, which exist in example texts, should be included into
this knowledge. This part of the universal knowledge, proposed in our
work, is described in the following sections. Logic-programming
language Sampletalk is included into this knowledge in order to
implement the synthesized algorithms. Sampletalk is described in the
following sections. Representation and processing of text samples is
described in Section 3. Proofs of the included theorems are given in
Appendix.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Note that we don&rsquo;t introduce
any a-priory assumptions for limiting text examples, which are used
for building algorithms. Relation of this approach to linguistics is
illustrated in natural language processing applications of Sampletalk
language, described in sections 3 and 4. Psychology and modeling of
the user's way of thinking, his gift for generalization and mental
associations, possibilities to involve computer in this creativity,
are the main points of our consideration.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<OL START=2>
	<LI><P ALIGN=LEFT><A NAME="_Toc467515549"></A><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5 STYLE="font-size: 20pt"><B>Data
	example based programming</B></FONT></FONT></P>
</OL>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Sampletalk may be considered as
simplification and modification of Prolog language. Sampletalk was
introduced in /15/ -- /17/. It involves elements related to Refal
/38/ and Planner /24/ languages. The main feature of this language is
similarity of the constructions for writing algorithms to the data
being processed. For this purpose, we sometimes use special notation
with underlines rather than square brackets for designation of nested
lists.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Syntax of Sampletalk language is
intentionally made extremely simple for logic programming. As the
modification of Prolog, Sampletalk may be defined by the following
conventions.</P>
<P CLASS="western" ALIGN=JUSTIFY>	1.1. The only basic data types in
Sampletalk is char, i.e. any Sampletalk data element is either a
single character or a list of Sampletalk data elements.</P>
<P CLASS="western" ALIGN=JUSTIFY>	1.2. Prolog terms, such as
[A<SUB>1</SUB>,A<SUB>2</SUB>,...,A<SUB>k</SUB>], where each A<SUB>i</SUB>
is either a single character constant or a single character variable
name (i.e. an upper-case alphabetic letter, in accordance with common
Prolog convention), are designated as A<SUB>1</SUB>A<SUB>2</SUB>....A<SUB>k</SUB>.
Other variable names currently have not been used. These terms are
called samples; their sub-lists (on any nesting level) are called
sub-samples. Uppercase single-character constants and several
constants used also for syntax purposes ([, ], {, }, double dot,
double comma, neck-symbol :-) are designated in a special way. Nested
samples are marked either by brackets or by underlining. 
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>EXAMPLES.</B> Prolog lists <B>['a',
'+', 'b', '=', C], [A, '+', B, '=', C] </B>and<B> [['(','a', '+',
'b',')'], '*', ['(',M, '+', N,')']]</B> have been written as samples<B>
a+b=C, A+B=C </B>and<B> [(a+b)]*[(M+N)]</B> respectively. Here <B>C,
A, B, M, N</B> are variable names. Samples in brackets and the
asterisk are elements of the last sample. Another notation for this
sample is <U><B>(a+b)</B></U><B>*</B><U><B>(M+N)</B></U>. Samples
<U><B>(a+b)</B></U><B>*, (a+b), +N</B> are examples of sub-samples
(on different levels) of the last sample.</P>
<P CLASS="western" ALIGN=JUSTIFY>	</P>
<P CLASS="western" ALIGN=JUSTIFY>	1.3. The only predicate in
Sampletalk is some 1-place predicate with empty name. Predicates have
been written in clauses without parentheses (simply by writing their
arguments), separated by neck-symbol <B>:-</B> and double commas,
terminated by double dot.</P>
<P CLASS="western" ALIGN=JUSTIFY>	So, clauses in Sampletalk have been
written in the form <I>w </I><B>:- </B><I>w</I><SUB><I>1</I></SUB><B>,,</B><I>w</I><SUB><I>2</I></SUB><B>,,</B><I>
... </I><B>,,</B><I>w</I><SUB><I>n</I></SUB><B>..</B><I>, </I>where<I>
w, w</I><SUB><I>1</I></SUB><I>, w</I><SUB><I>2</I></SUB><I>, ... ,w</I><SUB><I>n</I></SUB>
are samples.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western">	1.4. While matching two samples, a variable may
match not only an element of the opposite sample (like in Prolog). It
may match a segment, or sub-sample, formed by a adjacent sequence of
such elements.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Since there may be many
possibilities to match two samples, we introduce the following rule,
which will affect backtracking: <I>the more left an occurrence of a
variable in a sample, the less size of a sub-sample that is
considered for instantiation of this variable (starting from
1-character size).</I></P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>EXAMPLES.</B> Sample <B>a/b/c</B>
may match sample <B>A/B</B> in two ways: 1) <B>A=a</B>,<B> B=b/c</B>;<B>
2) A=a/b</B>,<B> B=c</B>. For matching sample <B>begin </B><U><B>spoke</B></U><B>
</B><U><B>rim</B></U><B> </B><U><B>hub</B></U><B> </B><U><B>wheel</B></U><B>
</B><U><B>frame</B></U><B> end</B> to sample <B>C </B><U><B>A</B></U><B>
B</B>, possible bindings of variables are represented in Fig. 2.1.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<TABLE WIDTH=590 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=49>
	<COL WIDTH=52>
	<COL WIDTH=62>
	<COL WIDTH=62>
	<COL WIDTH=52>
	<COL WIDTH=62>
	<COL WIDTH=43>
	<COL WIDTH=96>
	<TR VALIGN=TOP>
		<TD WIDTH=49>
			<P CLASS="western" ALIGN=CENTER><B>begin</B></P>
		</TD>
		<TD WIDTH=52>
			<P CLASS="western" ALIGN=CENTER><U><B>spoke</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>rim</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>hub</B></U></P>
		</TD>
		<TD WIDTH=52>
			<P CLASS="western" ALIGN=CENTER><U><B>wheel</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>Frame</B></U></P>
		</TD>
		<TD WIDTH=43>
			<P CLASS="western" ALIGN=CENTER><B>end</B></P>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
		<TD WIDTH=96>
			<P CLASS="western" ALIGN=CENTER><I>(1-st attempt)</I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=49>
			<P CLASS="western" ALIGN=CENTER><B>C</B></P>
		</TD>
		<TD WIDTH=52>
			<P CLASS="western" ALIGN=CENTER><U><B>A</B></U></P>
		</TD>
		<TD COLSPAN=5 WIDTH=336>
			<P CLASS="western" ALIGN=CENTER><B>\ - - - - - - - - - - - - - - -
			B - - - - - - - - - - - - - - - /</B></P>
		</TD>
		<TD WIDTH=96>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=CENTER><BR>
</P>
<TABLE WIDTH=590 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=49>
	<COL WIDTH=52>
	<COL WIDTH=62>
	<COL WIDTH=62>
	<COL WIDTH=52>
	<COL WIDTH=62>
	<COL WIDTH=43>
	<COL WIDTH=96>
	<TR VALIGN=TOP>
		<TD WIDTH=49>
			<P CLASS="western" ALIGN=CENTER><B>begin</B></P>
		</TD>
		<TD WIDTH=52>
			<P CLASS="western" ALIGN=CENTER><U><B>spoke</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>rim</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>hub</B></U></P>
		</TD>
		<TD WIDTH=52>
			<P CLASS="western" ALIGN=CENTER><U><B>wheel</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>Frame</B></U></P>
		</TD>
		<TD WIDTH=43>
			<P CLASS="western" ALIGN=CENTER><B>end</B></P>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
		<TD WIDTH=96>
			<P CLASS="western" ALIGN=CENTER><I>(2-nd attempt)</I></P>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD COLSPAN=2 WIDTH=115>
			<P CLASS="western" ALIGN=CENTER> <B>\ - - - - C - - - - /</B></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>A</B></U></P>
		</TD>
		<TD COLSPAN=4 WIDTH=260>
			<P CLASS="western" ALIGN=CENTER><B>\ - - - - - - - - - - - B - - -
			- - - - - - - - /</B></P>
		</TD>
		<TD WIDTH=96>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT>&hellip;</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<TABLE WIDTH=590 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=49>
	<COL WIDTH=52>
	<COL WIDTH=62>
	<COL WIDTH=62>
	<COL WIDTH=52>
	<COL WIDTH=62>
	<COL WIDTH=43>
	<COL WIDTH=96>
	<TR VALIGN=TOP>
		<TD WIDTH=49>
			<P CLASS="western" ALIGN=CENTER><B>begin</B></P>
		</TD>
		<TD WIDTH=52>
			<P CLASS="western" ALIGN=CENTER><U><B>spoke</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>rim</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>hub</B></U></P>
		</TD>
		<TD WIDTH=52>
			<P CLASS="western" ALIGN=CENTER><U><B>wheel</B></U></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>Frame</B></U></P>
		</TD>
		<TD WIDTH=43>
			<P CLASS="western" ALIGN=CENTER><B>end</B></P>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
		<TD WIDTH=96>
			<P CLASS="western" ALIGN=CENTER><I>(last attempt)</I></P>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD COLSPAN=5 WIDTH=332>
			<P CLASS="western" ALIGN=CENTER><B>\ - - - - - - - - - - - - - - -
			C - - - - - - - - - - - - - - - /</B></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=CENTER><U><B>A</B></U></P>
		</TD>
		<TD WIDTH=43>
			<P CLASS="western" ALIGN=CENTER><B>B</B></P>
		</TD>
		<TD WIDTH=96>
			<P CLASS="western" ALIGN=CENTER><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=CENTER><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Fig. 2.1. </B>Matching samples<B>
C </B><U><B>A</B></U><B> B </B>and<B> begin </B><U><B>spoke</B></U><B>
</B><U><B>rim</B></U><B> </B><U><B>hub</B></U><B> </B><U><B>wheel</B></U><B>
</B><U><B>frame</B></U><B> end</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Variable <B>A</B> can not bind
sub-sample, which contains 2 or more underlined words, since <B>A</B>
is underlined, and underlining structures of the matching samples
must match. Variables <B>C </B>and<B> B</B> (which are not
underlined) may match any sub-samples. See the last program example
of this section, where this matching is used.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	1.5. Any sample may be considered
as program goal. Resolved goal (that is, result of replacing all
variable names in this goal by values obtained during performance of
the program) is considered the result, or the output of the program.
Usually we place program goals at the top of the programs.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Only the user&rsquo;s wishes and
imagination limit expressing power of a language with so trivial
syntax and so various possibilities for interaction of language
constructions. For example, a program for sorting numbers may contain
fragment <B>A{N}{M}B ==&gt; A{M}{N}B :- {M&lt;N}</B> (see program
examples below); a program for reducing homogeneous items in an
analytic expression may contain fragment <B>A + M*X + N*X + B ---&gt;
A + L*X + B :- L = M + N</B> with respective clauses involving
constants <B>*</B>,<B> +</B>,<B> =</B> and the concept of number (<B>*
</B>and <B>+ </B>are considered as ordinary symbols and may be later
related to some machine-oriented operations).</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Program 1 shifts quantifiers into
the formula prefix for a disjunction of logic formulas:</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT STYLE="page-break-before: always"><BR>
</P>
<TABLE WIDTH=590 BORDER=0 CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=576>
	<TR>
		<TD WIDTH=576 VALIGN=TOP BGCOLOR="#d8d8d8">
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Goal (lines beginning with \% are
			comments):</P>
			<P CLASS="western" ALIGN=LEFT><B>(forall x</B><SUB><B>0</B></SUB><B>)[a(x</B><SUB><B>0</B></SUB><B>,y)]
			or (forall x</B><SUB><B>0</B></SUB><B>)[b(x</B><SUB><B>0</B></SUB><B>,t)]
			--&gt; W..</B></P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Program:</P>
			<P CLASS="western" ALIGN=LEFT><B>(Q X)[F] or (Q X)[H] --&gt; (Q
			X)(Q Z)([F] or [G]):-		</B>(1)</P>
			<P CLASS="western" ALIGN=LEFT><B>	[X] is variable,,</B></P>
			<P CLASS="western" ALIGN=LEFT><B>	[Z] is variable,,</B></P>
			<P CLASS="western" ALIGN=LEFT><B>	not(F contains Z),,</B></P>
			<P CLASS="western" ALIGN=LEFT><B>	(Z/X)[H]=[G]..</B></P>
			<P CLASS="western" ALIGN=LEFT><B>	[x</B><SUB><B>0</B></SUB><B>] is
			variable..						</B> (2)</P>
			<P CLASS="western" ALIGN=LEFT><B>[X</B><SUB><B>10</B></SUB><B>] is
			variable:-[X</B><SUB><B>0</B></SUB><B>] is variable..  				</B>
			(3)</P>
			<P CLASS="western" ALIGN=LEFT><B>AXB contains X..     						</B> <B>	</B>
			(4)</P>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[AXM]=[AYN]:-(Y/X)[M]=[N].. 
							</B> (5)</P>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[A]=[A]..     						</B> <B>	</B>
			(6)</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Program 1. Sampletalk program for
logic formula transformation</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Clause (1) almost literally quotes
well-known formal rule, which describes transformation of logic
formulas, along with informal constraints, which describe application
of this rule. Let us especially note that we turned these informal
constraints into formal components of a working algorithm. Clauses
(2) and (3) generate new names for logic variables in a logic
calculus, such as <B>x</B><SUB><B>0</B></SUB><B>,  x</B><SUB><B>10</B></SUB><B>,
x</B><SUB><B>110</B></SUB> etc. The predicate <B>not(</B><I>C</I><B>)</B>,
where <I>C</I> may be any sample, is built-in Sampletalk
construction, which succeeds if and only if goal <I>C</I> fails (like
negation in Prolog language). Clause (4) states that word <I>F</I>
contains word <I>Z</I> if <I>F</I> can be represented as <I>AZB</I>,
where <I>A </I>and<I> B </I>are words that surround <I>Z</I> in <I>F.</I>
Clauses (5) and (6) represent common notation for substitution of
terms (more detailed consideration of these clauses will be given in
the next section).</P>
<P CLASS="western" ALIGN=JUSTIFY>	Consider performance of this
program. Its goal matches head of clause (1), so <B>W</B> will be
bound to <B>(forall x</B><SUB><B>0</B></SUB><B>)(forall Z)([a(x</B><SUB><B>0</B></SUB><B>,y)]
or [G])</B>, where <B>Z</B> and <B>G</B> are still non-instantiated
variables (remind that uppercase letters in samples are Sampletalk
variable names). All occurrences of <B>Q</B> and <B>X</B> in (1) will
be replaced with <B>forall</B> and <B>x</B><SUB><B>0</B></SUB>
correspondingly. Then, generated sub-goal <B>x</B><SUB><B>0</B></SUB><B>
is variable</B> and <B>Z is variable</B> matches (2), and <B>Z</B>
will bind <B>x</B><SUB><B>0</B></SUB>. Then, sub-goal <B>F contains Z</B>
matches (4), and (1) fails, since <B>F</B> binds <B>a(x</B><SUB><B>0</B></SUB><B>,y)</B>
which contains <B>x</B><SUB><B>0</B></SUB>. After backtracking, <B>Z</B>
will match <B>x</B><SUB><B>10</B></SUB>, all the sub-goals of (1)
will be resolved, and <B>W</B> will be bound to <B>(forall x</B><SUB><B>0</B></SUB><B>)(forall
x</B><SUB><B>10</B></SUB><B>)([a(x</B><SUB><B>0</B></SUB><B>,y)] or
[b(x</B><SUB><B>10</B></SUB><B>,t))]</B>. The output will be <B>(forall
x</B><SUB><B>0</B></SUB><B>)[a(x</B><SUB><B>0</B></SUB><B>,y)] or
(forall x</B><SUB><B>0</B></SUB><B>)[b(x</B><SUB><B>0</B></SUB><B>,t)]
--&gt; (forall x</B><SUB><B>0</B></SUB><B>)(forall x</B><SUB><B>10</B></SUB><B>)([a(x</B><SUB><B>0</B></SUB><B>,y)]
or [b(x</B><SUB><B>10</B></SUB><B>,t)])</B>. In the next Section we
consider such samples as stimuli for synthesis of Sampletalk clauses.</P>
<P CLASS="western" ALIGN=JUSTIFY>	The same program may be used for
inverse transformation of logic formulas: elimination of parentheses
and extra quantifiers from the formula prefix. For this purpose we
simply replace the program goal with <B>W --&gt; (forall x</B><SUB><B>0</B></SUB><B>)(forall
x</B><SUB><B>10</B></SUB><B>)([a(x</B><SUB><B>0</B></SUB><B>,y)] or
[b(x</B><SUB><B>10</B></SUB><B>,t)]). </B>Variable <B>W </B>will be
bound to <B>(forall x</B><SUB><B>0</B></SUB><B>)[a(x</B><SUB><B>0</B></SUB><B>,y)]
or (forall x</B><SUB><B>0</B></SUB><B>)[b(x</B><SUB><B>0</B></SUB><B>,t)]</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	In the next version of this program
(see Program 2) we change constants, which define rule description
syntax, and add rule identification (see variable <B>R</B> in the
goal). This example shows that <I><B>we can limitlessly develop
similarity of strong algorithmic constructions to natural language
descriptions of formal objects</B></I>. As important is the opposite
observation: <I><B>we can take unconstrained natural language
description of an object or algorithm and transform it into a working
program</B></I>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<TABLE WIDTH=590 BORDER=0 CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=576>
	<TR>
		<TD WIDTH=576 VALIGN=TOP BGCOLOR="#d8d8d8">
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>%Goal:<BR><B>according to the rule
			R, the result of shifting quantifiers in the formula (/\
			x0)[a(x0,y)] \/ (/\ x0)[b(x0,t)] is formula W..<BR></B><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Program:<BR><B>according to the
			rule 2a from chapter 5, the result of shifting quantifiers in the
			formula (Q X)[F] \/ (Q X)[H] is formula (Q X)(Q Z)([F] \/ [G]) :-
			X is notation for variable,, Z is notation for variable,, not(word
			F contains word Z),, the result of replacing X by Z in formula H
			is G.. </B>
			</P>
			<P CLASS="western" ALIGN=LEFT><B>x0 is notation for variable..<BR>X10
			is notation for variable :- X0 is notation for variable..</B></P>
			<P CLASS="western" ALIGN=LEFT><B>word AXB contains word X..</B></P>
			<P CLASS="western" ALIGN=LEFT><B>the result of replacing X by Y in
			formula AXM is AYN :- the result of replacing X by Y in formula M
			is N..</B> <BR><B>the result of replacing X by Y in formula A is
			A..</B></P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Program 2. Another Sampletalk
program for logic formula transformation</B></P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western">	Program 2 provides another version of the Program
1. Note that no previous parsing of goals, building special data
types, memory structures, or any other programming effort is required
for forming and running these programs! 
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Samples in these programs are built
as results of generalization of the corresponding data processing
examples. The user in this case makes the generalization. In the next
sections, we consider such programs as objects of program synthesis.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Convention 1.4 makes essential
difference between Sampletalk and Prolog: such various bindings are
not allowed while matching terms and predicates in Prolog.
Nevertheless, they may be naturally incorporated into term
unification procedure and do not contradict to the paradigm of logic
programming. The following theorem illustrates similarity and
difference between Sampletalk and Prolog:</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>THEOREM 2.1.</B> For any
Sampletalk program <B>S</B>, an equivalent Prolog program <B>P</B>
consists of Prolog notations for all clauses from <B>S</B> and a set
of clauses, which are built from pairs of samples (<B>l,t</B>) of <B>S</B>
(the caller and the one being called) by including additional
sub-list forming brackets.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Proof of this theorem (see
Appendix) provides a way to implement Sampletalk interpreter using
Prolog interpreter. Another way (used in our implementation) consists
in addition of new possibilities for list matching to the standard
term unification procedure.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Although we eliminated important
features of Prolog (other data types, special syntax for terms,
predicate names, cut operator, side effects), Sampletalk is universal
programming language, as stated in the next theorem:</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><B>	THEOREM 2.2.</B> Let <B>S</B> be
alphabet of single-character constants of Sampletalk language, <B>M</B>
be any Markov algorithm written in terminal alphabet <B>U</B> and
non-terminal alphabet <B>V</B>, where <B>U </B>U<B> V </B>is subset
of<B> S</B>. There exists Sampletalk program <B>S</B><SUB><B>M</B></SUB>,
which, given any goal <I>w</I><B>==&gt;W</B> (where <I>w</I> is a
word, <B>W</B> is a Sampletalk variable), does the following:</P>
<P CLASS="western" ALIGN=JUSTIFY>	a) transforms it into output
<I>w</I><B>==&gt;</B><I>w</I><SUB><I><B>M</B></I></SUB>, where <I>w</I><SUB><I><B>M</B></I></SUB>
is result of application of <B>M</B> to <I>w</I>, if <I>w</I> is a
recognized word for algorithm <B>M</B>;</P>
<P CLASS="western" ALIGN=JUSTIFY>	b) stops with undefined results if
word <I>w</I> leads <B>M</B> to a deadlock stop, and</P>
<P CLASS="western" ALIGN=JUSTIFY>	c) shall not stop if <B>M</B> is
not applicable to word <I>w</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>(See Proof in Appendix).
Implementation of Markov algorithms written in other alphabets may be
done by encoding in the alphabet <B>S</B>. So, for any Markov
algorithm, an equivalent Sampletalk program can be constructed.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	The reader may get wrong impression
that Sampletalk can be used only for symbol processing. Other data
types may be represented using symbolic notation of other language
elements or by incorporating built-in machine oriented Prolog terms
and predicates (which is done in our current implementation). Refer
to /16/ for details. Our objective at this point, however, is not
study of Sampletalk in these directions, but automatic synthesis of
Sampletalk clauses.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="page-break-before: always"><BR>
</P>
<OL START=3>
	<LI><P ALIGN=LEFT><A NAME="_Toc467515550"></A><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5 STYLE="font-size: 20pt"><B>Representation,
	structurization, generalization and composition of text samples</B></FONT></FONT></P>
</OL>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Below we define constructions used
for discovery of regularities exposed in text samples. They enable us
to derive new useful samples and clauses from the existing ones.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>DEFINITION 3.1.</B> Let <I>u</I>
be a clause. Result of underlining a sub-sample <I>w</I> in any of
its samples is called <B>structurization</B> of <I>u</I>. For two
sub-samples <I>w</I><SUB><I>1</I></SUB> and <I>w</I><SUB><I>2</I></SUB>
of the same sample of <I>u</I>, simultaneous underlines are possible
either if <I>w</I><SUB><I>1</I></SUB> is sub-sample of <I>w</I><SUB><I>2</I></SUB><I>,
or w</I><SUB><I>2</I></SUB> is sub-sample of <I>w</I><SUB><I>1</I></SUB>,
or <I>w</I><SUB><I>1</I></SUB> and <I>w</I><SUB><I>2</I></SUB> have
no common sub-samples in <I>u</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>DEFINITION 3.2.</B> Let <I>C</I>
be a clause, and <I>w</I><SUB><I>1</I></SUB><I>,w</I><SUB><I>2</I></SUB><I>,
... ,w</I><SUB><I>k</I></SUB> are (non-intersecting) sub-samples of
any of its samples. Any result of replacing <I>w</I><SUB><I>1</I></SUB><I>,w</I><SUB><I>2</I></SUB><I>,
... ,w</I><SUB><I>k</I></SUB> with unique variable names <I>V</I><SUB><I>1</I></SUB><I>,V</I><SUB><I>2</I></SUB><I>,
... ,V</I><SUB><I>k</I></SUB> (which did not occur in <I>C</I>
before) is called <B>generalization</B> of <I>C</I> by converting its
sub-samples into variables. Clause <I>E</I> is called <B>common
generalization</B> of <I>C</I> and <I>D</I> if <I>E</I> is
generalization of <I>C</I> and generalization of <I>D</I>, and
<B>minimal common generalization</B> of <I>C</I> and <I>D</I> if
turning any variable of <I>E</I> into a constant violates the
property of being common generalization.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>DEFINITION 3.3.</B> <B>Initial
representation</B> of a text sample <I>w</I> is the fact (i.e. the
clause without body) <I>w</I>. <B>Representation</B> of <I>w</I> is
any Sampletalk clause, whose head is a result of structurization and
generalization of <I>w</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=LEFT>	<B>EXAMPLES</B> of samples and their
representations are given in Table 3.1:</P>
<P ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><BR>
</P>
<TABLE WIDTH=590 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=30>
	<COL WIDTH=260>
	<COL WIDTH=256>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT><I><B>No.</B></I></P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><I><B>Sample</B></I></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><I><B>Possible representation</B></I></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT>1</P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><B>a=&gt;a   	</B></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><B>[A]=&gt;[A]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT>2</P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><B>ab=&gt;ba</B></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><B>AB=&gt;BA..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT>3</P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><B>xy=&gt;yx</B></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><B>[AB]=&gt;[BA]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT>4</P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><B>abc=&gt;cba</B></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><B>[ABC]=&gt;[CBA]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT>5</P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><B>reverse of a is a</B></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><B>reverse of [A] is [A]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT>6</P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><B>reverse of a/b is b/a</B></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><B>reverse of [A/B] is [B/A]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P ALIGN=LEFT>7</P>
		</TD>
		<TD WIDTH=260>
			<P ALIGN=LEFT><B>reverse of a/b/c is c/b/a</B></P>
		</TD>
		<TD WIDTH=256>
			<P ALIGN=LEFT><B>reverse of [A/B/C] is [C/B/A]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>8</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>grass is a plant</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>X is a plant..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>9</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>Green is a color</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>X is a color..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>10</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>grass is green</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>X is Y:-X is a plant,,Y is a
			color..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>11</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>(y/x)a=a</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[A]=[A]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>12</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>(y/x)axb=ayb</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[AXB]=[AYB]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>13</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>(y/x)axbxc=aybyc</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[AXBXC]=[AYBYC]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>14</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>polish(a+b) is +ab</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>polish([A]+[B]) is +[A] [B]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>15</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>polish(a*b) is *ab</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>polish([A]*[B]) is *[A] [B]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>16</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>polish((a+b)*(c+d)) is *+ab+cd</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>polish([A]Z[B) is Z[A] [B]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>17</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>a fish lives in a sea; where does
			a fish live? in a sea 	</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>a X Ys in a Z; where does a X Y?
			in a Z..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>18</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>a tree grows in a forest; where
			does a tree grow? in a forest</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>a X Ys in a Z; where does a X Y?
			in a Z..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>19</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>axb contains x</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>AXB contains X..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>20</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>new york is situated in america</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>X is situated in L..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>21</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>a book is situated in the bag</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>X is situated in L..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>22</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>where is a book? in the bag</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>where is X? in L..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>23</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>where is new york? in america</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>where is X? in L..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>24</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>x</B><SUB><B>0</B></SUB><B> is
			variable</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>[x</B><SUB><B>0</B></SUB><B>] is
			variable..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>25</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>x</B><SUB><B>10</B></SUB><B> is
			variable</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>[X</B><SUB><B>10</B></SUB><B>] is
			variable..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>26</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>(forall x</B><SUB><B>0</B></SUB><B>)a
			or (forall x</B><SUB><B>0</B></SUB><B>)b --&gt; </B>
			</P>
			<P CLASS="western" ALIGN=LEFT><B>(forall x</B><SUB><B>0</B></SUB><B>)(forall
			x</B><SUB><B>10</B></SUB><B>)(a or b)</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>(forall X)[F] or (forall X)[H]
			--&gt;</B></P>
			<P CLASS="western" ALIGN=LEFT><B>(forall X )(forall Z)([F] or
			[H])..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>27</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>(forall x</B><SUB><B>0</B></SUB><B>)a(x</B><SUB><B>0</B></SUB><B>,y)
			or (forall x</B><SUB><B>0</B></SUB><B>)b(x</B><SUB><B>0</B></SUB><B>,t)
			--&gt;(forall x</B><SUB><B>0</B></SUB><B>)(forall x</B><SUB><B>10</B></SUB><B>)(a(x</B><SUB><B>0</B></SUB><B>,y)
			or b(x</B><SUB><B>10</B></SUB><B>,t))</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>(forall X)[F] or (forall X)[H]--&gt;</B></P>
			<P CLASS="western" ALIGN=LEFT><B>(forall X)(forall Z)([F] or
			[G])..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=30>
			<P CLASS="western" ALIGN=LEFT>28</P>
		</TD>
		<TD WIDTH=260>
			<P CLASS="western" ALIGN=LEFT><B>Permutation for 123456 is 412356</B></P>
		</TD>
		<TD WIDTH=256>
			<P CLASS="western" ALIGN=LEFT><B>permutation for [A[N]B] is [NW]..</B></P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Table 3.1. Text samples and their
representation as Sampletalk clauses</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Clause 2 from this table is minimal
common generalization of samples 2 and 3. Clause 3 is result of
structurization of clause 2. Clauses <B>reverse of A/M is N/A</B> and
<B>reverse of M/C is C/N</B> are minimal common generalizations of
samples 6 and 7. Clause <B>reverse of [A/M] is [N/A]:-reverse of [M]
is [N]</B> is generalization of clause <B>reverse of [A/B/C] is
[C/B/A]:-reverse of [B/C] is [C/B]</B>. Here sub-samples <B>B/C</B>
and <B>C/B</B> have been replaced with variable names <B>M</B> and <B>N</B>
respectively.</P>
<P CLASS="western" ALIGN=JUSTIFY>	We can see that generalization of a
sample always matches this sample.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>DEFINITION 3.4.</B> Let <I>H</I><SUB><I>1</I></SUB><I><B>:-</B></I><I>B</I><SUB>1</SUB>
and <I>H</I><SUB><I>2</I></SUB><I><B>:-</B></I><I>B</I><SUB><I>2</I></SUB>
be such results of structurization and generalization of clauses <I>C</I><SUB><I>1</I></SUB>
and <I>C</I><SUB><I>2</I></SUB> respectively, that all variable names
of <I>H</I><SUB><I>2</I></SUB> belong to <I>H</I><SUB><I>1</I></SUB><I><B>:-</B></I><I>B</I><SUB><I>1</I></SUB>
(<I>B</I><SUB><I>1</I></SUB> and <I>B</I><SUB><I>2</I></SUB>
designate bodies of the corresponding clauses, they may be empty).
Combined clause <I>H</I><SUB><I>1</I></SUB><I><B>:-</B></I><I>B</I><SUB><I>1</I></SUB><I>,,H</I><SUB><I>2</I></SUB>
is called <B>composition</B> of clauses <I>C</I><SUB><I>1</I></SUB>
and <I>C</I><SUB><I>2</I></SUB>. Initial clauses are called parents
of the composition.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>EXAMPLES.</B> Clause <B>reverse
of [A/M] is [N/A] :- reverse of [M] is [N]</B> is composition of
clause 7 with clause 6 from the above table. Here <I>H</I><SUB><I>2</I></SUB>
is sample <B>reverse of B/C is C/B</B>. During generalization,
sub-samples <B>B/C</B> and <B>C/B</B> were replaced with variable
names <B>M</B> and <B>N</B> respectively. Other examples of
compositions are presented in Table 3.2.</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<TABLE WIDTH=590 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=39>
	<COL WIDTH=62>
	<COL WIDTH=62>
	<COL WIDTH=370>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT><I><B>No.</B></I></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT><I><B>Parent</B></I></P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT><I><B>Parent</B></I></P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><I><B>Composition</B></I></P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>29</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>4</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>2</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>[AM]=&gt;[NA] :- [M]=&gt;[N]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>30</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>7</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>6</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>reverse of [A/M] is [N/A] :-
			reverse of [M] is [N]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>31</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>7</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>6</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>reverse of [M/C] is [C/N] :-
			reverse of [M] is [N]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>32</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>13</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>12</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[MXC]=[NYC] :-
			(Y/X)[M]=[N]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>33</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>13</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>12</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[AXM]=[AYN] :- (Y/X)[M=[N]..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>34</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>16</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>14</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>polish([M]*[(C+D)) is *[K] [+CD]
			:- polish(M) is K..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>35</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>34</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>14</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>polish([M]*[N]) is *[K] [L] :-
			polish(M) is K,, polish(N) is L..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>36</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>22</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>21</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>where is X? in L :- X is situated
			in L..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>37</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>23</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>20</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>where is X? in L :- X is situated
			in L..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>38</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>27</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>24</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>(Q X)[F] or (Q X)[H]--&gt;(Q X)(Q
			Z)([F] or [G) :- [X] is variable..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>39</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>38</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>24</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>(Q X)[F] or (Q X)[H]--&gt;(Q X)(Q
			Z)([F] or [G) :- [X] is variable ,, [Z] is variable..</B></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=39>
			<P CLASS="western" ALIGN=LEFT>40</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>39</P>
		</TD>
		<TD WIDTH=62>
			<P CLASS="western" ALIGN=LEFT>33</P>
		</TD>
		<TD WIDTH=370>
			<P CLASS="western" ALIGN=LEFT><B>(Q X)[F] or (Q X)[H]--&gt;(Q X)(Q
			Z)([F] or [G]) :- [X] is variable ,, [Z] is variable ,,
			(Z/X)[H]=[G]..</B></P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Table 3.2. Composition of
Sampletalk clauses</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Note that clauses 30 and 31 (as
well as 32 and 33) are essentially different compositions of the same
clauses. Note also that clauses 36 and 37 are identical compositions
of parent clauses of different origins.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Composition of clauses may involve
new recursion. Therefore, we obtain much more powerful clauses for
text processing than the initial representations of samples. Indeed,
group of clauses, consisting of a composition and one of the parents
or another simple clause, can serve as the recursive rule and the
boundary condition for reversing any word (pair 29,1), reversing any
list of words separated by slash-symbols (pair 30,5), for replacing
non-intersecting occurrences of a sub-word X of a word W by a word Y
for any X,W,Y (pair 33,11), for processing of natural language
phrases, for transformation of mathematical and logical expressions
etc. 
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">To
clarify semantics of such programs, consider Program 3, constructed
from pair (33,11), with some goal. (See also Program 1 where these
clauses are applied).</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="page-break-before: always"><BR>
</P>
<TABLE WIDTH=590 BORDER=0 CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=576>
	<TR>
		<TD WIDTH=576 VALIGN=TOP BGCOLOR="#d8d8d8">
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Goal (W stands for the result of
			the replacing):</P>
			<P CLASS="western" ALIGN=LEFT><B>(z2/z1)[(sin(z1)+cos(z1))]=[W]..</B></P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Program:</P>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[AXM]=[AYN] :-
			(Y/X)[M]=[N].. 					</B>(33)</P>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[A]=[A]..  								</B>(11)</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=CENTER><B>Program 3. Representation of
common notation for term substitution in an expression. The result
will be (z1/z2)[(sin(z1)+cos(z1))]=[(sin(z2)+cos(z2))]</B>.</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	This program performs global
replacing of sub-words and may be used for changing variables in
logical or arithmetical expressions. Sub-words <B>z1 </B>in word
<B>(sin(z1)+cos(z1))</B> will be globally replaced with sub-words <B>z2</B>.
Consider this in more detail. Program goal matches head of clause 33,
then instance <B>(z2/z1)[(sin(z1)+cos(z1))]=[(sin(z2N]</B> of this
head is constructed. After this matching, <B>Y</B> is <B>z2</B>,  <B>X</B>
is <B>z1</B>, <B>A</B> is <B>(sin(</B>, <B>M</B> is <B>)+cos(z1))</B>,
<B>N</B> is undefined. The sub-goal in the body of this clause will
have form <B>(z2/z1)[)+cos(z1))]=[N]</B> (remind that &ldquo;<B>=</B>&rdquo;
is an ordinary character rather than specific construction of
Sampletalk language).</P>
<P CLASS="western" ALIGN=JUSTIFY>	Once more, this sub-goal matches
(33), and we have: <B>A</B> is <B>)+cos(</B>, <B>M</B> is <B>))</B>,
<B>N</B> is undefined. The next sub-goal <B>(z2/z1)[))]=[N]</B> does
not match (33) but matches (11), and  successive bindings will give
us the following: <B>N</B> is <B>))</B>; return; <B>N</B> is
<B>)+cos(z2))</B>; return; <B>W</B> is <B>(sin(z2)+cos(z2))</B>, and
the output of the program will be
<B>(z1/z2)[(sin(z1)+cos(z1))]=[(sin(z2)+cos(z2))]</B>. Compare this
output to samples 11-13 from the above table and note its similarity
to them. It may be considered as their inductive extension for domain
of arithmetic expressions.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Pair (32,11) does not fit the task
of global replacing variables in an expression: the program,
consisting of this pair of clauses, replaces only the first
occurrence of <B>X</B> by <B>Y</B>. 
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<TABLE WIDTH=590 BORDER=0 CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=576>
	<TR>
		<TD WIDTH=576 VALIGN=TOP BGCOLOR="#d8d8d8">
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Goal (W stands for the result of
			the replacing):</P>
			<P CLASS="western" ALIGN=LEFT><B>(z2/z1)[(sin(z1)+cos(z1))]=[W]..</B></P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Program:</P>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[MXC]=[NYC] :-
			(Y/X)[M]=[N].. 					</B>(32)</P>
			<P CLASS="western" ALIGN=LEFT><B>(Y/X)[A]=[A]..  								</B>(11)</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><B>Program 4. This program replaces
only the first occurrence of z1 with z2. The result will be
(z1/z2)[(sin(z1)+cos(z1))]=[(sin(z1)+cos(z2))]</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>This is due to the standard strategy
of matching samples (see Convention 1.4 from previous section).
Likewise, program, consisting of the pair (31,5), shifts first
element of a word list into the end of the list rather than reversing
the list, as the pair (30,5) does.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>The following two programs operate
with word lists.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<TABLE WIDTH=590 BORDER=0 CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=576>
	<TR>
		<TD WIDTH=576 VALIGN=TOP BGCOLOR="#d8d8d8">
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>%Goal</P>
			<P CLASS="western" ALIGN=LEFT><FONT COLOR="#000000"><B>reverse of
			[abc/def/gh] is X..</B></FONT><FONT COLOR="#000000">					<BR></FONT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Program</P>
			<P CLASS="western" ALIGN=JUSTIFY><B>reverse of [M/C] is [C/N] :-
			reverse of [M] is [N]..				</B>(31)</P>
			<P CLASS="western" ALIGN=JUSTIFY><B>reverse of [A] is
			[A]..								</B> (5)</P>
			<P CLASS="western" ALIGN=JUSTIFY><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><B>Program 5. Shifting the first
element of a word list into the end of the list. The result will be
</B><FONT COLOR="#000000"><B>reverse of [abc/def/gh] is
[def/gh/abc]..</B></FONT><FONT COLOR="#000000">					<BR></FONT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<TABLE WIDTH=590 BORDER=0 CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=576>
	<TR>
		<TD WIDTH=576 VALIGN=TOP BGCOLOR="#d8d8d8">
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>%Goal</P>
			<P CLASS="western" ALIGN=LEFT><FONT COLOR="#000000"><B>reverse of
			[abc/def/gh] is X..</B></FONT><FONT COLOR="#000000">					<BR></FONT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Program</P>
			<P CLASS="western" ALIGN=JUSTIFY><B>reverse of [A/M] is [N/A] :-
			reverse of [M] is [N]..				</B>(30)</P>
			<P CLASS="western" ALIGN=JUSTIFY><B>reverse of [A] is
			[A]..								</B> (5)</P>
			<P CLASS="western" ALIGN=JUSTIFY><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><B>Program 6. Reversing list of words
separated by /. The result will be <FONT COLOR="#000000">reverse of
[abc/def/gh] is [gh/def/abc].</FONT></B></P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	We recommend the reader to consider
pair (30,5) in detailed performance (at least in mind if you don't
have Sampletalk interpreter). This program reverses words rather than
lists, so the output will be <B>reverse of [ab/cd/ef] is [fe/dc/ba]</B>,
similar to (29,1). Example applications of such clauses for reversing
words were considered in previous sections.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Some of the program examples,
considered in Section 2.2.3, can be obtained from clauses taken from
tables 3.1 and 3.2.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Program 7 represents interesting
program example, constructed from clauses like 20-23 and 36:</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<TABLE WIDTH=590 BORDER=0 CELLPADDING=7 CELLSPACING=0>
	<COL WIDTH=576>
	<TR>
		<TD WIDTH=576 VALIGN=TOP BGCOLOR="#d8d8d8">
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Goal:</P>
			<P CLASS="western" ALIGN=LEFT><B>where is new york? in L..</B>   
								<B>	</B> (2.3.1)</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT>% Knowledge base:</P>
			<P CLASS="western" ALIGN=LEFT><B>who is X? R :- X is R..</B>  
									(2.3.2)</P>
			<P CLASS="western" ALIGN=LEFT><B>where is X? in L :- X is situated
			in L..</B>  				(2.3.3)</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
			<P CLASS="western" ALIGN=LEFT><B>joe is son of maria and peter..	</B>
							(2.3.4)</P>
			<P CLASS="western" ALIGN=LEFT><B>julia is daughter of maria and
			peter..</B>				(2.3.5)</P>
			<P CLASS="western" ALIGN=LEFT><B>peter 2 is son of maria and peter
			1..</B> 				(2.3.6)</P>
			<P CLASS="western" ALIGN=LEFT><B>jack 2 is son of julia and jack
			1..</B>  				<B>	</B> (2.3.7)</P>
			<P CLASS="western" ALIGN=LEFT><B>ann is a teacher..</B>   							
			(2.3.8)</P>
			<P CLASS="western" ALIGN=LEFT><B>new york is situated in america..</B>
								(2.3.9)</P>
			<P CLASS="western" ALIGN=LEFT><B>st.petersburg is situated in
			russia..</B>  				(2.3.10) 
			</P>
			<P CLASS="western" ALIGN=LEFT><B>a book is situated in the bag..</B>
								(2.3.11) 
			</P>
			<P CLASS="western" ALIGN=LEFT><B>a tree is situated in the
			forest..</B>  					(2.3.12)</P>
			<P CLASS="western" ALIGN=LEFT><BR>
			</P>
		</TD>
	</TR>
</TABLE>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><B>Program 7. Small reasoning system
built from natural language phrases</B></P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">In the
next section, synthesis of such programs will be discussed. This
program represents a reasoning system working with natural language.
All its clauses are initial representations, generalizations, and
compositions of some natural language expressions, which describe a
knowledge base; associations among them simultaneously serve as the
language parser, grammar, and as an inference engine. Using this
approach, the programmer does not need to design a grammar, parser,
knowledge model, and inference engine as separate program components:
they are represented <I>implicitly</I> in samples.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	The program allows one to ask
various questions (in the form of program goals), like:</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>X is son of maria and Y..</B> ?
(<B>X</B> will match <B>joe</B>, then <B>peter 2</B>, so we can use
natural language questions to immediately inquire the knowledge
base);</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>jack N is Y of Z..</B> ? (<B>Y</B>
will be instantiated with son, <B>Z -</B>-- with <B>julia and jack 1</B>,
so we can extract from the knowledge base not only the subjects'
names, but also the user's concepts);</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>X 2 is son of Y and X 1..</B> ?
( <B>X</B> will be instantiated with <B>peter</B>, then with<B> jack</B>,
so we can express a situation, in which different objects have
similar names);</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>who is julia? R..</B> ? (<B>R</B>
will be instantiated with <B>daughter of maria and peter</B>, so we
can obtain more complex descriptions of objects from the knowledge
base, if such descriptions were provided by knowledge engineer);</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>where is new york? in L..</B> ?
(<B>L</B> will be instantiated with <B>america</B>, and we get the
output <B>where is new york? in america..</B>, so we can extract not
only fragments of the facts, but also compositions or derivations of
that fragments);</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>what is in the bag? R</B>.. ? (<B>R</B>
will be instantiated with nothing; we should include into the
database additional knowledge like <B>what is in X? R:-R is situated
in X..</B> so that we could obtain the result <B>what is in the bag?
a book..</B>; so, we can immediately use fragments of a natural
language discourse and their abstractions in order to enlarge our
inference engine).</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	The knowledge base itself has
natural language form and may be easily enlarged in the same manner;
we may as easily obtain natural language explanation of derived
samples if we use special Sampletalk interpreter option, which prints
information about all intermediate matching. For the goal (2.3.1),
the explanation will look like the following: 
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in"><B>where
is new york? in L; </B>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in"><B>new
york is situated in america; </B>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in"><B>where
is new york? in america.</B> 
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	In this way, Sampletalk language
ties up some very important programming concepts: Logic Programming,
Databases, Knowledge Representation, Generalization, Natural Language
Modeling, Symbol Manipulation, Pattern Matching. These concepts are
represented in the language implicitly, without complex syntax and
semantics. This feature (along with its simplicity) allows us to
consider Sampletalk, in family of AI languages, in position analogous
to position of Basic language in conventional programming language
family. The user may be unaware that simple programs, which he
creates using this technology, may be exceptionally complex for other
approaches and programming languages.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<OL START=4>
	<LI><P ALIGN=LEFT><A NAME="_Toc467515551"></A><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5 STYLE="font-size: 20pt"><B>Incremental
	Sampletalk clause synthesis</B></FONT></FONT></P>
</OL>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Compare Table 1.2 from our
Introduction with Tables 3.1 and 3.2. By means of structurization,
generalization and composition of samples (still made manually), we
can represent hypotheses about regularities, which are manifested in
data processing samples. Sampletalk programs serve to transform these
regularities into programs. In this section, we will outline some
paths to automatic or semi-automatic construction of such programs,
and describe current state of our experiments with Sampletalk program
synthesis.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Consider Program 7 once more. This
program (or its program equivalent) can be constructed by the
following sequence of actions:</P>
<P CLASS="western" ALIGN=JUSTIFY>	1). Take samples (2.3.4 -- 2.3.12).
Include their initial representations into the created program.</P>
<P CLASS="western" ALIGN=JUSTIFY>	2). Take samples <B>who is joe? son
of maria and peter</B> and  <B>joe is son of maria and peter</B>.
Construct their composition <B>who is joe? son of maria and
peter:-joe is son of maria and peter</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY>	3). Take samples <B>who is ann? a
teacher</B> and <B>ann is a teacher</B>. Construct composition <B>who
is ann? a teacher:-ann is a teacher</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY>	4). Find minimal common
generalization of those compositions. It will be sample <B>who is X?
Y:-X is Y</B>. Include this clause into the created program (clause
2.3.2).</P>
<P CLASS="western" ALIGN=JUSTIFY>	5). Obtain clause, equivalent to
(2.3.3), in similar way, from samples involving the concepts <B>where</B>
and <B>situated</B>. Include it into the program.</P>
<P CLASS="western" ALIGN=JUSTIFY>	We can vary this program if we vary
initial samples and clause generation strategy. For instance, we may
consider samples <B>who is joe? son of maria and peter</B> and <B>who
is ann? daughter of evelyn and ivan</B> as a stimulus for the
generalization, construct clause <B>who is X? Y of Z and T</B> from
them and then obtain clause <B>who is X? Y of Z and T:-X is Y of Z
and T</B> as some composition instead of (2.3.2). This clause will
match another class of goals, but while associating with facts (2.3.4
-- 2.3.12) it will work as well as (2.3.2), for any questions but
questions concerning <B>ann</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY>	</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">So, we
have a few actions for transformation of data processing examples
into data processing clauses. This transformation can be automated if
we allow the computer to form plausible hypotheses and do not bore
the user with too difficult actions for evaluating them. For simple
samples, such as 1 -- 4 from Table 3.1, all possible representations,
generalizations and compositions can be found by simple exhaustion.
The task of the user, who composes a program using the synthesizer,
in this case is reduced to evaluation of generated compositions
against other examples (e.g. test whether the generated program can
reverse a test word <B>abcdef</B>). This testing can be automated
using positive (correct) and negative (incorrect) examples of text
transformation. 
</P>
<P CLASS="western" ALIGN=JUSTIFY>	In more complex case, when such
exhaustion is impossible, we may use an ordered teaching sequence of
samples, as well as some previously constructed clauses, where useful
(from the user's point of view) regularities are already discovered
and stored as a useful knowledge. Here we assume that the user can
evaluate each synthesized clause as successful or unsuccessful. He
can test it against other examples of correct and incorrect text
processing, or use special evaluation functions for this purpose.
Some problems of this approach are mentioned in below. 
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Let <I>w</I><SUB><I>1</I></SUB><I>,w</I><SUB><I>2</I></SUB><I>,...,w</I><SUB><I>k</I></SUB>
be an incremental sequence of samples. We do not define here the
concept of incremental sequence of samples in a formal way.
Informally, we assume that there exists some similarity of any <I>w</I><SUB><I>i</I></SUB>
to a <I>w</I><SUB><I>j</I></SUB> (<I>j&lt;i</I>) and <I>w</I><SUB><I>j</I></SUB>
is simpler than <I>w</I><SUB><I>i</I></SUB> (<I>w</I><SUB><I>j</I></SUB>
may be empty word). Probably, the user can provide the synthesizer
with such sequence of samples, basing on his intuitive concept of
text similarity and complexity.</P>
<P CLASS="western">	We assume that the synthesizer can take into
account already created clauses for synthesis of new clauses. Various
ways to organize a synthesizer by using composition and
generalization of clauses are possible. A general scheme of our
synthesizer is defined by the following procedure:</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>ALGORITHM 4.1.</B> (Synthesis of
a program <B>S</B>). 
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Given text samples <I><B>w</B></I><SUB><I><B>1</B></I></SUB><I><B>,w</B></I><SUB><I><B>2</B></I></SUB><I><B>,...,w</B></I><SUB><I><B>k</B></I></SUB>,
perform the following steps, starting from <I><B>w</B></I><SUB><I><B>1</B></I></SUB>
and terminating with <I><B>w</B></I><SUB><I><B>k</B></I></SUB><B> </B>:
</P>
<P CLASS="western" ALIGN=JUSTIFY>	1. Build some representation <I><B>C</B></I><SUB><I><B>i</B></I></SUB>
of sample <I><B>w</B></I><SUB><I><B>i</B></I></SUB>, which was not
built before, using structurization, generalizations and compositions
of <I><B>C</B></I><SUB><I><B>1</B></I></SUB><I><B>,C</B></I><SUB><I><B>2</B></I></SUB><I><B>,...,C</B></I><SUB><I><B>i-1</B></I></SUB>
and of initial representations (i.e. facts<B>)</B><I><B>
w</B></I><SUB><I><B>1</B></I></SUB><I><B>,w</B></I><SUB><I><B>2</B></I></SUB><I><B>,...,w</B></I><SUB><I><B>i</B></I></SUB>.</P>
<P CLASS="western" ALIGN=JUSTIFY>	If the user approves <I><B>C</B></I><SUB><I>i</I></SUB>,
place it at the top of the program <B>S</B> and go to Paragraph 2.
Otherwise, go to Step 1.</P>
<P CLASS="western" ALIGN=JUSTIFY>	2. Choose the next sample and go to
Step 1. If <I><B>i = k</B></I>, then the program <B>S</B> is built.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	The following theorem, along with
the Theorem 2.2, shows that this synthesizer can be used for
synthesis of any algorithm.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	<B>THEOREM 4.1.</B> For any
Sampletalk program <B>S</B>, an equivalent Sampletalk program <B>S</B><SUB><B>1</B></SUB>
can be constructed by applying Algorithm 4.1 to some sequence of
samples <I><B>w</B></I><SUB><I><B>1</B></I></SUB><I><B>,w</B></I><SUB><I><B>2</B></I></SUB><I><B>,...,w</B></I><SUB><I><B>k</B></I></SUB>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>(see Proof in Appendix).</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	This theorem has interesting
implications related to programming technology. It shows that we can
build any algorithm without programming at all, simply by combination
of data examples that expose behavior of the desired algorithm.
Programming in Sampletalk language assumes that we build the
algorithm from examples manually. Now we find that we even don&rsquo;t
have to build the program manually. Algorithm 4.1 can do this for us.
Our task is only to provide examples for the program synthesizer and
organize the examples in such manner that the necessary regularities
will be discovered in the necessary order.</P>
<P CLASS="western" ALIGN=JUSTIFY>	</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">So, <I><B>we
can build any algorithm without programming in a computer language</B></I>:
all we need is to form the necessary sequence of data processing
examples, which is characteristic for the algorithm being built. This
way of programming assumes alternative way of thinking about objects
and processes and can lead to powerful programming techniques.
Sampletalk program examples illustrate this for natural language
processing and math applications. 
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">Today,
however, people don&rsquo;t use data generalization while writing
programs. Probably, for some applications, forming characteristic
sequence of data examples is not an easy task. This method needs
experimental approval and experience. 
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Algorithm 4.1 represents only a
general program synthesis scheme and may generate too many program
versions to be useful in applications. We should modify it for
special text fields or for obtaining special kind of programs. Many
options for such modification are possible.</P>
<P CLASS="western" ALIGN=JUSTIFY>	We can do without initial
representation of samples <I><B>w</B></I><SUB><I><B>1</B></I></SUB><I><B>,
w</B></I><SUB><I><B>2</B></I></SUB><I><B>, ..., w</B></I><SUB><I><B>i-1</B></I></SUB>,
and use only clauses <I><B>C</B></I><SUB><I><B>1</B></I></SUB><I><B>,
C</B></I><SUB><I><B>2</B></I></SUB><I><B>, ..., C</B></I><SUB><I><B>i-1</B></I></SUB><I>
</I>and<I> </I><I><B>w</B></I><SUB><I><B>i</B></I></SUB><B> </B>at
each step of the synthesis; the version space is reduced. Another way
of reducing the version space consists in applying only minimal
common generalizations to the initial samples. We may apply special
constraints while underlining and generalizing sub-samples.
Interesting generalization strategy consists in underlining each
replaced sub-word in resulting clauses, so that the user will be able
to control the process of synthesis by including matching and
mismatching sub-words into initial samples.</P>
<P CLASS="western" ALIGN=JUSTIFY>	The result of this interactive
program synthesis depends on the initial sequence of samples and on
evaluation of generated clauses by the user. Each step may lead to
explosion. However, since the user is the source of the initial
information, we can expect a reasonable combination of his informal
assumptions about samples, with formal properties of those samples.
Proper sequence of samples and correct strategy for underlining
perspective sub-words may drastically reduce exhaustion of possible
compositions and generalizations.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Synthesizer may be organized in
such a way that any Sampletalk program can be generated without
exhaustion at all, provided with a proper sequence of samples. The
synthesis in this case is deterministic and is similar to
compilation. However, providing so detailed and precise sequence of
samples may be a very complex task.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	So, we have two extreme approaches
to interactive program synthesis: 
</P>
<UL>
	<LI><P CLASS="western" ALIGN=JUSTIFY>Simple sequence <I><B>w</B></I><SUB><I><B>1</B></I></SUB><I><B>,w</B></I><SUB><I><B>2</B></I></SUB><I><B>,...,w</B></I><SUB><I><B>k</B></I></SUB>
	and complex user's actions for evaluating generated clauses that may
	lead to explosion; 
	</P>
	<LI><P CLASS="western" ALIGN=JUSTIFY>Complex incremental sequence
	<I><B>w</B></I><SUB><I><B>1</B></I></SUB><I><B>,w</B></I><SUB><I><B>2</B></I></SUB><I><B>,...,w</B></I><SUB><I><B>k</B></I></SUB>
	(beginning from basic sub-words for structurization of further
	constructions) and trivial user's actions (if any) for evaluating
	clauses. 
	</P>
</UL>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.5in"><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">Reasonable
technology of synthesis is, probably, somewhere between. We can
simplify preparation of samples and make the computer work out a
reasonable class of constructions.</P>
<P CLASS="western" ALIGN=JUSTIFY>	The next important possibility for
composing new programs consists in using already created and verified
programs rather than single clauses. Suppose, for instance, that we
want to build a program for transformation of analytic expressions
into a canonical form. Usually this task involves sorting and
reduction (summation) of homogeneous items. We may use 1) an already
created program for sorting a list of items; 2) samples for reduction
of sub-lists of homogeneous items. We should not mix samples for
sorting with samples for reduction, since they may interact in
undesired way and provide unpredictable results. Technically, we can
build these program fragments into the generated program by marking
clauses with a special prefix (which plays the same role as unique
predicate names for groups of Prolog clauses). In this way, we can
reduce exhaustion and help the user to control the process of
synthesis. 
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">So, the
system, depicted here, is not simple Machine Learning system, but
one, which learns from a clever tutor: the result of learning heavily
depends on text samples and on applied strategy of synthesis.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Current experiments with Sampletalk
language interpreter have lead us to new programming technology,
which can be described as follows: <I><B>data processing example
abstraction immediately provides a useful program if matching of text
abstractions is in focus</B></I>. Now we have various applications
with symbol-numeric processing in linguistics, music and algebra (see
/15/,/20/). In experiments with synthesis, we implemented procedure
for building common and minimal common generalizations for a set of
samples. Other steps of the synthesis algorithm are currently
performed manually, in order to find and verify reasonable strategy
of algorithm synthesis for given classes of samples. This is our
appeal for the reader: detail or modify Algorithm 4.1 for your data
samples and, probably, you will get new programming technology for
processing your data.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P ALIGN=LEFT><A NAME="_Toc467515552"></A><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5 STYLE="font-size: 20pt"><B>Related
work</B></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Generalization technique in logic
calculus was systematically described in Michalsky /33/ and applied
and investigated in various works, e.g. Langley et al /30/ (for
discovery of new chemical compounds), Gleibman /20/ (for discovery of
equations with complex term structure). This technique causes
considerable interest and applications in latest research. Furtado
/13/ presents Prolog program, which builds the most specific
generalization (minimal common generalization in our terminology) for
a pair of Prolog structures which may contain various combinations of
identical variables.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Generalization of sub-samples,
composition and generalization of clauses, described here, may be
considered as application of this technique in Sampletalk context.
Other kind or generalization, proposed by Michalsky (e.g.
generalization of antecedent), probably, will be used in future
versions of our synthesizer.</P>
<P CLASS="western" ALIGN=JUSTIFY>	The paradigm of inductive program
synthesis has been investigated in various works (beginning from
synthesis of Turing machines and recursive functions). The approach
of Barsdin, Kinber and Brasma /4/, /5/, /28/, /29/ is based on
generalization of computation examples. Authors propose special
programming language for expressing sample computations and
algorithms, and then introduce technique for detecting so called
syntactical analogies in examples. The analogies are basically
related to fragments of arithmetical progressions, that implicitly
reflect assignments in form x:=x+c and x:=x-c. Reasoning and program
synthesis are related to arrays. Set of expressions like &ldquo;a(3)&lt;b(1)?
yes, then a(3)-&gt;c(3)&rdquo; is generalized into an array
processing program (for sorting, merging arrays etc). The
implementation language for generated algorithms (so called graphic
language) contains traditional programming constructions for cycles,
arithmetic operators, logic conditions an so on. This work is related
to program synthesis from full information-logical history of
constructed program (see Bierman /6/, Angluin &amp; Smith /3/). 
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">In
Vityaev /40/, Prolog program synthesis is related to discovery of
probabilistic regularities in Prolog expressions. Shapiro's /36/
approach to Prolog program synthesis is based on covering input set
of Prolog clauses by more general clauses.</P>
<P CLASS="western" ALIGN=JUSTIFY>	There is a work in synthesis of
formal language grammars, regular expressions, and templates by
examples. Angluin /2/ introduced algorithm for constructing the most
specific template for a group of text examples and suggests to use
this algorithm in data input systems and text editors (this is
proposal to organize text editing by example).</P>
<P CLASS="western" ALIGN=JUSTIFY>	Chuzhanova /8/ presents a system
for building &quot;pattern grammars&quot; for analysis of genetic
texts. Synthesis is based on detection and inductive generalization
of specific types of regularities (repetitions, inversions, and
common subsequences) in a finite set of positive examples. These
types of regularities represent a-priori information for the system.
(Is this a universal knowledge in the sense of Table 1 from our
Introduction?). In our approach, we try to minimize applied universal
knowledge as much as possible. The mentioned types of regularities
for the genetics texts might be expressed by the following Sampletalk
clauses with recursion:</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><B>word [AXB] contains repetition of the word [Z]:-</B></P>
<P CLASS="western" ALIGN=LEFT><B>	[X] is repetition of [Z]..</B></P>
<P CLASS="western" ALIGN=LEFT><B>[XX] is repetition of [X]..</B></P>
<P CLASS="western" ALIGN=LEFT><B>[ZX] is repetition of [Z]:- [X] is
repetition of [Z]..</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><B>words [AXB] and [CYD] have inversion
fragments [X] and [Y]:-</B></P>
<P CLASS="western" ALIGN=LEFT><B>	reverse of [X] is [Y]..</B></P>
<P CLASS="western" ALIGN=LEFT><B>reverse of [AM] is [NA]:-reverse of
[M] is [N]..</B></P>
<P CLASS="western" ALIGN=LEFT><B>reverse of [A] is [A]..</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><B>words [AXV*] and [BXW*] have common
subsequence (X,S.):-</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT> <B>words [V*] and [W*] have common
subsequence (S.)..</B></P>
<P CLASS="western" ALIGN=LEFT> <B>words [*] and [*] have common
subsequence (.)..</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>(see also clauses 29,1, 30 and 5
from Tables 3 and 4 in Section 2. The asterisks play the same role as
empty list <B>[ ]</B> in Prolog programs. From the other hand,
concepts of repetition, inversion and common subsequence are
fundamental for research in genetics, and may be regarded as the
universal knowledge.</P>
<P CLASS="western" ALIGN=JUSTIFY>	This example shows that our
minimalist approach to universal knowledge does not hinder us from
expressing specific kinds of universal knowledge. This confirms
simplicity and power of our knowledge-processing tool, in comparison
to other knowledge processing tools.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Many papers describe grammar
induction. In Vanlehn and Ball /39/, version space for possible
grammars, consistent with a set of examples, is investigated.
Jansen-Winkeln /26/ describes grammar rule generation system LEGAS,
which is based on maximum and minimum specific conjunctive
generalization of example string sets. From the example set D= (lady
-&gt; ladies), (body -&gt; bodies) the following rules are
constructed: str,[dy] -&gt; str,[dies] (maximum specific); str,[y] -&gt;
str,[ies] (minimum specific). In Sampletalk notation, the same rules
are represented as generalizations of samples lady ---&gt; ladies and
body ---&gt; bodies into Xdy ---&gt; Xdies or Xy ---&gt; Xies.
However, we are not so concentrated in formal language grammar (is
this a universal knowledge concept?).I believe that this concept
should be excluded from explicit use anywhere it's possible. Our
natural language processing programs (refer to Program 6 in Section 2
and the program for morphologic analysis of Finnish language [17]) do
not use with this concept and therefore are simple.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Considering these examples, note
that researchers make hard efforts to transform natural language
descriptions into formal objects as relational databases (e.g. see
Alshawi /1/), frames, grammars an so on. The objective of this
transformation is application of reasoning tools that are more usable
for formal objects than for NL phrases. Our examples show that,
sometimes, direction of this transformation should be opposite: we
would better represent necessary reasoning in form of natural
language reasoning, and then compose special reasoning system from
abstractions of these texts. This is my recommendation for natural
language processing designers. Sampletalk seems to be quite useful
for implementation of this approach. 
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Approach to analysis and synthesis
of formal constructions on the ground of informal human reasoning has
its own history and applications. Zavalishin and Muchnik /43/
investigated human mechanisms of analysis of complex graphic images
(including geometrical illusions). They experimented with verbal
image descriptions. The authors present a table of graphic images
with informal hypotheses about them, which is similar to our Table 2
from Section 1 (for graphic case), and try to build a shape
dictionary for a graphic language.</P>
<P CLASS="western" ALIGN=JUSTIFY>	There is research in synthesis of
new descriptions based on analogies (e.g. Winston /42/; Haraguchi and
Arikawa /23/). In the second paper, pairing of terms for two Prolog
programs is defined. It is used for constructing new clauses, and may
involve new recursion. Our means of generating new recursive rules
are based on text matching rather than analogies, although these
concepts have much in common.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Botta /7/ introduces concept of
conjunctive maximally specific characterization (MSC) of a set of
examples, along with algorithms for generation of MSC. The author
represents examples from a block world domain. The MSC, the most
specific generalization, our minimal common generalization of
samples, and other constructions of this kind (e.g. Michalsky /33/)
are analogous constructions that highlight similar elements among
instances in various fields. Usage of this tool in discovery and
application of regularities is developed in AI research and
applications. Critical point of view is expressed by Macdonald and
Witten /32/: they believe that discovery based learning (at all) is
quite immature an does not yet form a foundation for practical
knowledge acquisition techniques.</P>
<P CLASS="western" ALIGN=JUSTIFY>	The technique of <I>synthesis from
examples </I>has been investigated in many other works. Gallant /14/
describes generation of a medical expert system from examples of
diseases and treatments. The induction is based on so called learning
matrix (a matrix of dependencies between terminal variables and goal
variables). This matrix is constructed by analysis of the
dependencies in the example treatment descriptions; the generated
expert system is built up on this matrix. This approach can be used
for any problem domain, which may be described by means of
discriminate characteristics; the synthesized inference engine is
based on dependencies between them. There are various approaches to
automatic generation of formal descriptions and generalizations in
such fields. Examples of descriptive rules formation for a large set
of experimental data with discriminate characteristics are described,
for instance, in Ho et al /25/. The generation is based on a priori
information about attributes of observed objects and on set-theory
relations between classes of objects. This approach is suitable for a
description of discrete events or facts, which are not bound by
functional relations. For working with text data (as in our paper) or
continuous physical phenomena, it is more suitable to use a logic
calculus or logic programming language than set theory, for complex
concepts and interrelations can be implicitly expressed in them.
Delgrande /10/ describes an approach to formation of hypotheses about
relations on domains that are represented by a set of positive and
negative facts. For representation of hypotheses a special formal
language is used which contains functors analogous to traditional
set-theory operations and logic copulas. From our point of view, this
set of functors also isn't suitable for working with arbitrary text
data.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	In Gleibman /20/, a formal approach
to hypothesis formation and generalization is introduced, for
learning structure of a continuous physical world interconnected by
complex functional relations. The proposed discovery component deals
with simultaneous differential equations; some heuristics are given
for forming new equations from case revelations of the physical
phenomena. This approach leads us to a conceptual generalization (of
the concepts which are implicitly represented in the equations),
while the present work is more close to a descriptive generalization
(in the sense of Michalsky /33/). There are various projects
concerning reasoning about equations (see review in Silver /37/).
Silver describes inductive generation of new equation processing
rules on the basis of correct inference examples provided by the
user.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Constructing Sampletalk language,
we have eliminated syntax features of Prolog language, which hinder
the synthesizer (as well as the human programmer) from assuming
analogies and comparing predicates with different names and term
structures. At the same time, symbol constants in samples, such as
constants <B>)</B>, <B>(</B>, <B>=</B>, or more expressive constants
such as <B>is</B>, <B>contains</B>, <B>not</B> etc., may constrain
Sampletalk program performance in the similar way as Prolog specific
constructions constrain Prolog performance (see Sampletalk version of
Clocksin and Mellish Prolog program for working with parts inventory
in Section 1 and our representation of merge sort algorithm in
Appendix 2. These programs present results of direct rewriting of the
corresponding Prolog programs in Sampletalk language).</P>
<P CLASS="western" ALIGN=JUSTIFY>	The advantage of notation with
underlines for designation of sub-samples consists in keeping text
entirety and readability; this notation may be considered as an
attempt to involve graphic elements into the programming language
area (we feel that such elements, as well as indices and fonts may
not only improve readability of the program code, but provide a new
expressive power for programming languages). We believe that it is an
interesting research problem. Some consideration of this problem is
given in D.Knuth's article &quot;Literate Programming&quot;.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Although Sampletalk language
initially was designed only for experiments with automatic program
synthesis, it turned out (surprisingly for us) to be useful for
programming by a human. Sampletalk is extremely simple. At the same
time, Sampletalk comprises and ties up the most expressive elements
of such languages as Prolog (clause call, recursion, backtracking,
unification), Refal and Planner (list matching and involving
variables into the further processing). Curiously, the mentioned
programming technology, based on the human ability to generalize his
data, became clear only after debugging the interpreter on samples
from different fields. Our implementation and experiments with
Sampletalk language demonstrate its power for various classes of
problems (especially linguistic problems) and domains.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Some technical relation may be
mentioned, between our approach to generalization and some other
approaches. In systems GLAUBER, NGLAUBER (see Langley et al /30/ and
also Jones /27/), generalization of statements is done by adding and
expansion of the effect of quantifiers in the first order calculus.
The obtained hypotheses are verified according to input statements
(that are represented similar to Prolog facts). In our case,
replacing sub-samples with variables does the similar action. 
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">An
important problem, which arises with the inductive program synthesis,
is verification of the generated programs. This problem is analogous
to the problem of evaluation of hypotheses in other discovery systems
(e.g., see Mitchell et al. /32/). Probably, the technique of
programming, proposed in our work, is more feasible for easy creation
of program prototypes with non-critical reliability or for creation
of programs whose working results are immediately analyzed by the
user (e.g. formation of plausible hypotheses for semi-automatic
recognition of an ancient natural language text on the basis of
bilingual text samples; an immediate synthesis of a prototype of a
translator for some artificial language represented by sample
expressions and their translations, etc.). Development of new methods
for a formal verification of the synthesized programs can be
connected with formal analysis of text samples.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Application of Sampletalk language
and technology to linguistic problems seems to be very promising. In
Gleibman and Kirsanov /17/, check-spelling problem for so highly
inflected language as Finnish is considered. Sampletalk program is
presented for resolving this problem. The program is written directly
in terms of linguistics rather than in programmer's slang, and
consists of clauses like</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><B>correctness of the word [A] is [correct(A)]:-</B></P>
<P CLASS="western" ALIGN=LEFT><B>	X of [Y] will be [A],,</B></P>
<P CLASS="western" ALIGN=LEFT><B>[Y] is a stem..</B></P>
<P CLASS="western" ALIGN=LEFT><B>present tense 3rd person singular of
[A] will be [DVV]:-</B></P>
<P CLASS="western" ALIGN=LEFT><B>	[A] ends in vocal [V], begins with
[D]..</B></P>
<P CLASS="western" ALIGN=LEFT><B>[Y] is a stem:-stems X/Y/Z..</B></P>
<P CLASS="western" ALIGN=LEFT><B>stems
//ole/tule/saa/voi/sano/mene/n\&quot;ake/pit\&quot;a/tiet\&quot;a/teke//..</B></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Analogous program for Russian check
spelling was written by the author. Using such clauses, we can
describe morphology of many languages, as well as inference rules for
deduction of new constructions (e.g. translations) from existing
ones. Note that knowledge in computer programming area is not
required for the author of this program. Important is understanding
of the process of <I>matching samples.</I> Now we can imagine clause
synthesis technology for automatic or semi-automatic extraction of
such clauses from linguistic literature.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Semiautomatic Sampletalk program
synthesis reminds language grammar retrieval based on the examples of
language expressions. For example, rather than designing a natural
language grammar, we can use sample words such as <I>embedded,
emphasized</I> for generating samples <I>emXed, Xed</I>, which may
implicitly represent concepts of prefix, suffix and tense. In
explicit form, these concepts may be not in use at all in the
program. Its designer may do without these concepts. Bilingual
translation samples may be used for developing a natural language
text translator without programming, simply by choosing and
structurization of suitable samples.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Our version of the synthesizer is
interactive. It is using evaluation of generated clauses by the user.
In other versions, this evaluation may be automated by statistical
analysis, heuristic evaluation functions, by synthesis and evaluation
of characteristic data examples for evaluation of given clauses, etc.</P>
<P CLASS="western" ALIGN=JUSTIFY>	The synthesizer may be organized so
that only clauses <I>C</I><SUB><I>1</I></SUB><I>,C</I><SUB><I>2</I></SUB><I>,...,C</I><SUB><I>i-1</I></SUB>
and the initial representation of the sample <I>w</I><SUB><I>i</I></SUB>
will be used for creating <I>C</I><SUB><I>i</I></SUB>. Such
synthesizer is still able to generate any algorithm, but requires
another approach for choosing samples and evaluation of the generated
program. What kind of the synthesizer is suitable for which sort of
the problems?</P>
<P CLASS="western" ALIGN=JUSTIFY>	Probably, participation of clauses,
which were already included into the program being created, is
preferable for the synthesis process, in comparison to their text
origins. Experiments with various synthesizers and sets of samples
may clarify this question and give us a pragmatic concept of their
applicability.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Paradigm of <I>creating something
new on the basis of observing something</I> instead of (or, to some
extent, along with) using a sophisticated a priori knowledge, is
rather promising not only in relation to inductive learning,
discovery and generalization. Many interactive computer systems may
be related to this paradigm if we consider the user as a part of the
system (e.g., systems for interactive creation of graphic images from
basic icons: the user himself represents the universal knowledge for
creation of new images). Well-known Query-by-Example language (Zloof
/44/) is related to analysis of the user's actions with a model of a
relational table on the screen; the system's actions with real tables
are generated automatically from these actions.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	The most important feature of such
systems (from our point of view) is possibility to create essentially
new complex objects without programming, simply by combining and
transforming existing ones &quot;by hand&quot;, in accordance with
their own automatic properties. Where are the limits and advantages
of this approach? 
</P>
<P CLASS="western" ALIGN=JUSTIFY>	In Gleibman /22/, this approach is
investigated for creation and animation of graphic images by using
basic images (graphic samples and their abstractions) under
constraints influenced by other graphic images and some a priori
types of transformation and composition of samples. The latter types
represent a universal knowledge for the graphic synthesizer (linear
and other transformations, composition of graphic objects by gluing
&quot;point to point&quot;, &quot;a point slides along a line&quot;,
by gluing lines with rolling friction; animation of compositions by
gluing objects with some earlier animated objects, etc). This
approach allows one to create complex technical scenarios without
programming, simply by manual processing and controlling samples.
Technology of program synthesis, described here, may be considered as
an attempt to expand this approach into data processing area.</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P ALIGN=LEFT><A NAME="_Toc467515553"></A><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5 STYLE="font-size: 20pt"><B>Summary</B></FONT></FONT></P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>We have shown that various kinds of
useful text processing programs can be created by providing the
synthesizer with demo samples of data processing, instead of writing
program code.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Sampletalk is universal programming
language. Sampletalk programming and program synthesis are
essentially based on data examples and their structurization,
generalization and composition. Natural language reasoning is one of
perspective applications for Sampletalk.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Technique for program synthesis,
described here, can be used for producing any word processing
algorithm, basing on a proper set of text samples.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P ALIGN=LEFT><A NAME="_Toc467515554"></A><FONT FACE="Swiss, Arial, sans-serif"><FONT SIZE=5 STYLE="font-size: 20pt"><B>Appendix.
Proofs</B></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><B>1. Proof of the Theorem 2.1.</B>
Construction of the program <B>P</B> we begin by writing each clause
of <B>S</B> in the Prolog form in accordance with Conventions 1.2 and
1.3 (we choose some unique predicate name pname for all predicates).
Then, for each matching pair of samples l, t of <B>S</B> (caller and
the one being called), we construct all possible groups of Prolog
clauses in the form</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT>pname(L):-pname(L<SUB>1</SUB>,M,N,K),  
					(1) 
</P>
<P CLASS="western" ALIGN=LEFT>pname(L<SUB>1</SUB>,M,N,K):-pname(T<SUB>1</SUB>,M,N,K),
				(2) 
</P>
<P CLASS="western" ALIGN=LEFT>pname(T<SUB>1</SUB>,M,N,K):-pname(T),
					(3)</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>Here list L (T) is the Prolog
notation of the sample l (t), list L<SUB>1</SUB> (T<SUB>1</SUB>) is
formed from the list L (T) by adding zero or more pairs of square
brackets so that pname(L<SUB>1</SUB>) matches pname(T<SUB>1</SUB>) as
Prolog predicates (let us call them specifications of the original
samples), M is the number of a calling clause, N is the number of a
call in the clause body, K is the number of a clause being called.
Place these groups in the program P in accordance to Convention 1.4
of Section 1.</P>
<P CLASS="western" ALIGN=JUSTIFY>	This set of clauses is finite due
to the finiteness of the set of all possible specifications of the
samples (we do not allow lists like [[L]] within these lists).</P>
<P CLASS="western" ALIGN=JUSTIFY>	As the goal for this program we
will use predicate pname(W<SUB>P</SUB>), where W<SUB>P</SUB> is the
Prolog representation of the goal of <B>S</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Now let us show that the program <B>S</B>
is equivalent to the program <B>P</B>. For any successful Sampletalk
call (l,t), where l is a sample from a clause body, t is the head of
a clause being called, there exist such specifications L<SUB>1</SUB>
and T<SUB>1</SUB> that L<SUB>1</SUB> match T<SUB>1</SUB> according to
the Prolog unification rules. In the program <B>P</B> the
corresponding call is implemented by the successive calls (1), (2),
(3). These calls make the same environment change (i.e. bindings of
free variables) as the above Sampletalk call.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Likewise, for each successful
sequence of Prolog calls in the form  (pname(L), pname(L<SUB>1</SUB>,M,N,K),
pname(T<SUB>1</SUB>,M,N,K), pname(T)) in the program <B>P</B>, the
correspondent environment change is made by the Sampletalk call
(l,t), where l and t are Sampletalk notations of the predicates
pname(L) and pname(T). So, the programs <B>S</B> and <B>P</B> are
equivalent.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><B>2. Proof of the Theorem 2.2.</B> 
Compose the program <B>S</B><SUB><B>M</B></SUB> of the clauses in the
form</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT> <B>X</B>a<SUB>i</SUB><B>Y==&gt;W :-
X</B>b<SUB>i</SUB><B>Y==&gt;W..</B> 					(1)</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>for the normal (Markov) rules a<SUB>i</SUB>
-&gt; b<SUB>i</SUB> of the algorithm <B>M</B>, and of the facts in
the form</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT> <B>X</B>a<SUB>j</SUB><B>Y==&gt;X</B>b<SUB>j</SUB><B>Y..</B>
 						(2)</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>for the terminating rules a<SUB>j</SUB>
-&gt;. b<SUB>j</SUB> of the algorithm <B>M</B>. The order of the
clauses in <B>S</B><SUB><B>M</B></SUB> corresponds to the order of
the rules in <B>M</B>. Clause (fact) <B>X==&gt;Z..</B> we add at the
bottom of <B>S</B><SUB><B>M</B></SUB>. Here <B>X</B>,<B> Y</B>,<B> W</B>
are Sampletalk variable names.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Now let us show that working of <B>S</B><SUB><B>M</B></SUB>
is equivalent to the working of <B>M</B>. Let word <B>w==&gt;W</B> be
the goal for <B>S</B><SUB><B>M</B></SUB>. If <B>w</B> is a recognized
word for <B>M</B> and one of the rules a<SUB>i</SUB> -&gt; b<SUB>i</SUB>
or a<SUB>j</SUB> -&gt;. b<SUB>j</SUB> is applied to <B>w</B>, then <B>w</B>
can be represented in the form <B>X</B>a<SUB>i</SUB><B>Y</B> or <B>X</B>a<SUB>j</SUB><B>Y</B>,
and therefore in <B>S</B><SUB><B>M</B></SUB> one of the clauses (1)
or (2) is called. In the case (1), a sub-goal <I>w' </I><B>==&gt; W</B>
is formed, where w' is a word produced by the algorithm <B>M</B> from
<B>w</B>. In the case (2), the program will resolve the goal and
stop. In this case, variable <B>W</B> gets value <B>X</B>b<SUB>j</SUB><B>Y</B>
with <B>X</B> and <B>Y,</B> which were bound before. This correspond
to the result of applying <B>M</B> to <B>w</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Due to Convention 1.4 (Section
X.X.1), all the variables <B>X</B> in the clauses (1), (2) will match
sub-words of minimal possible sizes. This correspond to the canonical
application of the substitution rules in Markov algorithms.</P>
<P CLASS="western" ALIGN=JUSTIFY>	Consider the case when <B>w</B>
leads <B>M</B> to the deadlock stop, i.e. when there is some
derivation w' of <B>w</B> for which no rule of <B>M</B> is
applicable. In this case, program <B>S</B><SUB><B>M</B></SUB> comes
to a sub-goal w' <B>==&gt; W</B> which does not match any clause head
of <B>S</B><SUB><B>M</B></SUB> but the last one. This last clause
<B>X==&gt;Z</B> serves for preventing backtracking; variable <B>W</B>
matches the undefined variable <B>Z</B>, and the program stops.</P>
<P CLASS="western" ALIGN=JUSTIFY>	At last, let word <B>w</B> be such
that <B>M</B> will never stop to process it. This means that for each
derivation w' of <B>w</B> only rules in the form (1) are applicable.
In the program <B>S</B><SUB><B>M</B></SUB> this process corresponds
to successive bindings <B>W=</B>w', <B>W=</B>w'' etc., and the
program shell never stop.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><B>3. Proof of the Theorem 4.1.</B>
Let <I>C</I><SUB><I>1</I></SUB><I>,C</I><SUB><I>2</I></SUB><I>,...,C</I><SUB><I>n</I></SUB>
be the clauses of the program <B>S</B> in reverse order. To build <B>S</B><SUB><B>1</B></SUB>,
we construct an equivalent clause for each <I>C</I><SUB><I>i</I></SUB>
and keep the order of these clauses, beginning from the bottom of <B>S</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY>	First, we construct a sequence E of
samples for <B>S</B><SUB><B>1</B></SUB> using the following
procedure:</P>
<P CLASS="western" ALIGN=JUSTIFY>	For <I>i = 1,2,...,n,</I> perform
the following steps:</P>
<P CLASS="western" ALIGN=JUSTIFY>	1) If <I>C</I><SUB><I>i</I></SUB>
is a clause without body (i.e. fact), construct two instances <I>u</I><SUB><I>i</I></SUB>
and <I>w</I><SUB><I>i</I></SUB> of <I>C</I><SUB><I>i</I></SUB> so
that <I>C</I><SUB><I>i</I></SUB> is their minimal common
generalization. This can be done by global replacing all variables of
<I>C</I><SUB><I>i</I></SUB> with two sets of unique samples (one set
for <I>u</I><SUB><I>i</I></SUB> and one set for <I>w</I><SUB><I>i</I></SUB>).
Add <I>u</I><SUB><I>i</I></SUB> and <I>w</I><SUB><I>i</I></SUB> to E.</P>
<P CLASS="western" ALIGN=JUSTIFY>	2) If <I>C</I><SUB><I>i</I></SUB>
has a body, construct a unique instance <I>w</I><SUB><I>ij</I></SUB>
for each its sample b_j (including the head) by global replacing each
its variable with some unique sample, so that similar variables
correspond to similar samples. Add all such <I>w</I><SUB><I>ij</I></SUB>
to E.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	Now let us apply Algorithm 4.1 to
the sequence E. For each <I>C</I><SUB><I>i</I></SUB> there exists a
pair of instances <I>u</I><SUB><I>i</I></SUB> and <I>w</I><SUB><I>i</I></SUB>
or a set of instances <I>w</I><SUB>ij</SUB> in E such that <I>C</I><SUB><I>i</I></SUB>
is their minimal common generalization or composition. Thus, some
clause <I>C</I><SUB><I>i' </I></SUB> can be created, such that the
only differences between <I>C</I><SUB><I>i</I></SUB> and <I>C</I><SUB><I>i'</I></SUB>
are the names of the correspondent variables, so that these clauses
are equivalent. Therefore, the program <B>S</B><SUB><B>1</B></SUB> is
equivalent to the program <B>S</B>.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P ALIGN=JUSTIFY STYLE="page-break-after: avoid"><FONT FACE="Dutch, Times New Roman, serif"><FONT SIZE=5><I><B>REFERENCES</B></I></FONT></FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in"><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in"><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	1. Alshawi, H. Creating Relational
Databases From English Texts. Artificial Intelligence Applications.
The Engineering of Knowledge-Based Systems. Ch. R. Weisbin, ed. IEEE
CS Press. North-Holland, 1985, pp. 390-395.</P>
<P CLASS="western" ALIGN=JUSTIFY>	2. Angluin, D. Finding patterns
common to a set of strings.  J. Comput. Systems Sci. - 1980, V.21,
pp.46-62. 
</P>
<P CLASS="western" ALIGN=JUSTIFY>	3. Angluin, D. and Smith, C.H.
Inductive Inference: Theory and Methods. Comput. Surveys, 1983, V.15,
No. 3, pp. 237-364.</P>
<P CLASS="western" ALIGN=JUSTIFY>	4. Barsdin, J.M., Brasma, A.N. and
Kinber, E.B. Inductive Synthesis: State, Problems, Perspectives.
Kibernetika, No.6, 1987, pp.81-86,90. In Russian.</P>
<P CLASS="western" ALIGN=JUSTIFY>	5. Barsdin, J.M. Some rules of
inductive inference and their role for program synthesis. Information
Processing 83. Amsterdam: North Holland, 1983, pp. 333-338.</P>
<P CLASS="western" ALIGN=JUSTIFY>	6. Bierman, A.W., Krishnaswamy R.
Constructing programs from example computations. IEEE Trans. Software
Eng. - 1976, No.2, pp. 141-153.</P>
<P CLASS="western" ALIGN=JUSTIFY>	7. Botta, M. Constructive learning
in conjunctive concept characterization. Methodologies for
Intelligent Systems, 3. Z.M.Ras, L. Saitta, eds., North Holland,
1988.</P>
<P CLASS="western" ALIGN=JUSTIFY>	8. Chuzhanova, N.A. Inductive
synthesis of programs for symbolic sequences processing. Analogical
and Inductive Inference. Intern. Workshop AII'89 Proc.,
Reinhardsbrunn Castle, East Germany, Spr.-Ver. 1989, pp.317-327.</P>
<P CLASS="western" ALIGN=JUSTIFY>	9. Clocksin, W.F. and Mellish, C.S.
Programming in Prolog. Springer-Verlag, 1984.</P>
<P CLASS="western" ALIGN=JUSTIFY>	10. Delgrande, J.P. A formal
approach to learning from examples. Int. J. Man-Machine Studies,
V.26, 1987, pp. 123-141.</P>
<P CLASS="western" ALIGN=JUSTIFY>	11. Dontas, K. and Zemankova, M.
APPLAUSE: An Experimental Plausible Reasoning System. Methodologies
for Intelligent Systems, 3. Z.M.Ras, L. Saitta, eds., North Holland,
1988.</P>
<P CLASS="western" ALIGN=JUSTIFY>	12. Falkenhainer, B.C., Michalsky,
R.S. Integrating Quantitative and Qualitative Discovery: The ABACUS
System. Machine Learning, V.1, pp.367-401, 1986.</P>
<P CLASS="western" ALIGN=JUSTIFY>	13. Furtado, A.L. Analogy by
generalization --- and the quest of the grail. ACM SIGPLAN Notes,
V.27, No. 11, January 1992, pp.105-113.</P>
<P CLASS="western" ALIGN=JUSTIFY>	14. Gallant, S.I. Automatic
generation of expert systems from examples. Artificial Intelligence
Applications. The Engineering of Knowledge-Based Systems.
Ch.R.Weisbin, ed. IEEE CS Press. North-Holland, 1985, pp. 313-319.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in">	15.
Gleibman, A.H. Sample: New Programming Technology and AI Language
(Subtitle: Data processing example abstraction immediately becomes a
useful program if text matching is in focus).<I> ACM SIGSAM Bulletin
No.2, 1992, 10 pp.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in">	16.
A.H.Gleibman. Sample: The Simplest Language for Artificial
Intelligence Problems. <I>Preprint of the Institute of Theoretical
Astronomy of the Russian Academy of Sciences No.19, 1992, 54 pp.  In
Russian.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in">	17.
Andrew H. Gleibman and Nikolai O. Kirsanov. Data generalization as a
Programming Technology.<I> Manuscript, 8 pp. In publishers.</I></P>
<P CLASS="western" ALIGN=JUSTIFY>	18. A.H.Gleibman. Synthesis of Text
Processing Programs by Example: The Sample Language. <I>Preprint of
the Institute of Theoretical Astronomy of the Russian Academy of Sci.
No.15, 27 pp.,1991. In Russian. </I>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in">	19.
A.H.Gleibman. Text Example Generalization: Inductive Synthesis of
Sample Language Programs. <I>Manuscript, 30 pp. Submitted for
publication.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in">	20.
A.H.Gleibman. Reasoning About Equations: Towards Physical Discovery.
<I>Preprint of the Institute of Theoretical Astronomy of the Russian
Academy of Sciences No.18, 1992, 37 pp. In Russian.</I></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in">	21.
A.H.Gleibman. Automatic construction of equations for celestial
mechanics on the ground of observation data. <I>Thes. of papers of
the Soviet conference &quot;Methods for Computer  Modeling of Classic
and Celestial Mechanics&quot;,  Leningrad,  1989,  p.30</I>.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in">	22.
A.H.Gleibman. Computer Graphics System Design on the ground of
samples. <I>In book: Applied Informatics, No.2 (Moscow, 1986,  pp. 
5-18). In Russian.</I></P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY>	23. Haraguchi, M and Arikawa, S. A
Foundation of Reasoning by Analogy: Analogical Union of Logic
Programs. Lecture Notes in Computer Science, V.264, pp.58-69, 1986.</P>
<P CLASS="western">	24. Hewitt, C. Description and Theoretical
Analysis (Using Schemata) of PLANNER: A Language for Proving Theorems
and Manipulating Models in a Robot. TR-258, - AI Lab.,MIT, Cambridge,
Mass., 1983.</P>
<P CLASS="western" ALIGN=JUSTIFY>	25. Ho, T.B.; Diday, E.;
Getler-Summa, M. Generating rules for expert systems from
observations. Pattern Recognition Letters No.7, 1988, pp. 265-271.</P>
<P CLASS="western" ALIGN=JUSTIFY>	26. Jansen-Winkeln, R.M. LEGAS --
Inductive Learning of Grammatical Structures. Artificial Intelligence
and Expert Systems. S.Savory, ed. Ellis Horwood Ltd, John Wiley &amp;
Sones, 1988, pp. 206-217.</P>
<P CLASS="western" ALIGN=JUSTIFY>	27. Jones, R. Generating
predictions to aid the scientific process. Proc. of AAAI-86: Fifth
Nat. Conf. on AI, Philadelphia, PA, USA, 11-15 Aug. 1986, pp.
513-517.</P>
<P CLASS="western" ALIGN=JUSTIFY>	28. Kinber, E.B. Syntactical
inductive synthesis of iterative programs. Computers and Art. Int.,
V.8,1989, No.6, pp.565-580.</P>
<P CLASS="western" ALIGN=JUSTIFY>	29. Kinber, E.B. Syntactical
Inductive Synthesis According to Examples of Programs Containing
Conjunctive Conditions in Loops.  Kibernetika, 1988, No. 6, pp.23-28.
In Russian.</P>
<P CLASS="western" ALIGN=JUSTIFY>	30. Langley, P.; Bradshaw, G.;
Simon, H.A. Rediscovering Chemistry with the Bacon System. Machine
Learning: An Artificial Intelligence Approach, R. Michalski, J.G.
Carbonell, and T.M. Mitchell, eds., Tioda Press, Palo Alto, Calif.,
1983.</P>
<P CLASS="western" ALIGN=JUSTIFY>	31. Lenat, D.B. The Nature of
Heuristics. Artificial Intelligence, V.19, No.2, pp.189-249, 1982.</P>
<P CLASS="western" ALIGN=JUSTIFY>	32. Macdonald, B.A., Witten, I.H. A
Framework for Knowledge Acquisition Through Techniques of Concept
Learning. IEEE Transactions on Systems, Man, and Cybernetics. V.19,
No.3, 1989, pp. 499-512.</P>
<P CLASS="western" ALIGN=JUSTIFY>	33. Michalski, R.S. A Theory and
Methodology of Inductive Learning. Artificial Intelligence, V.20,
No.2, pp.111-161, 1983.</P>
<P CLASS="western" ALIGN=JUSTIFY>	34. Mitchell, T.B.; Keller, R.M.;
Kedar-Cabelli, S.T. Explanation-Based Generalization: A Unifying
View. Machine Learning, V.1, No.1, pp. 47-80, 1986.</P>
<P CLASS="western" ALIGN=JUSTIFY>	35. Rose, D; Langley, P. Chemical
Discovery as Belief Revision.  Machine Learning, V.1, No.4, 1986, pp.
423-451.</P>
<P CLASS="western" ALIGN=JUSTIFY>	36. Shapiro, E. Algorithmic program
debugging. Cambridge (Mass.): MIT Press, 1983 (122 p).</P>
<P CLASS="western" ALIGN=JUSTIFY>	37. Silver, B. Meta-level
inference. North-Holland-Amsterdam-New York-Oxford, 1986.</P>
<P CLASS="western" ALIGN=JUSTIFY>	38. Turchin, V.F. Algorithmic
language of recursive functions (REFAL). Institute of Applied
Mathematics of USSR Ac. of Sci. Moscow, 1968 (in Russian).</P>
<P CLASS="western" ALIGN=JUSTIFY>	39. Vanlehn, K. and Ball, W. A
version Space Approach to Learning Context-free Grammars. Machine
Learning, V.2, 1987, pp. 39-74.</P>
<P CLASS="western" ALIGN=JUSTIFY>	40. Vityaev, E.E. Inductive
synthesis of Prolog programs by discovery of regularities. Problems
of Program Synthesis, Verification and Debugging. Riga, LGU, 1986,
pp. 65-66. In Russian.</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="text-indent: 0.5in">41 Vigant
I. Natural Language Processing by Examples. Master Thesis. Comp. Sci.
Dept., Technion, Haifa 1997.</P>
<P CLASS="western" ALIGN=JUSTIFY>	42. Winston, P.H. Learning new
principles from precedents and exercises. Artificial Intelligence,
V.19, pp.321-350, 1983.</P>
<P CLASS="western" ALIGN=JUSTIFY>	43. Zavalishin, N.B. and Muchnik,
I.B. Visual perception models and image analysis algorithms. Moscow,
&quot;Nauka&quot;, 1974, p. 205. In Russian.</P>
<P CLASS="western" ALIGN=JUSTIFY>	44. Zloof, M. Query by Example.
AFIPS Conf. Proc. V. 44, 1975, pp. 431-438.</P>
<P CLASS="western" ALIGN=JUSTIFY>	45. Zytkow, J.M.; Simon, H.A. A
theory of historical discovery: The construction of componential
models. Machine Learning, V.1, No. 1, pp. 107-136.</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY><BR>
</P>
<P CLASS="western" ALIGN=LEFT><BR>
</P>
<P CLASS="western" ALIGN=LEFT><FONT SIZE=2>==========================================================================</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY> Please cite this paper as follows: 
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in"><FONT COLOR="#008000">A.H.Gleibman.
Synthesis of Text Processing Programs by Example: The Sample
Language. <I>Preprint of the Institute of Theoretical Astronomy of
the Russian Academy of Sci. No.15, 27 pp.,1991. In Russian. </I></FONT>
</P>
<P CLASS="western" ALIGN=LEFT><FONT SIZE=2>==========================================================================</FONT></P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in"><BR>
</P>
<P CLASS="western" ALIGN=JUSTIFY STYLE="margin-left: 0.06in"><BR>
</P>
<DIV TYPE=FOOTER>
	<P ALIGN=LEFT STYLE="margin-top: 0.26in"><FONT SIZE=2>Sampletalk		<SDFIELD TYPE=PAGE SUBTYPE=RANDOM FORMAT=ARABIC>29</SDFIELD>	</FONT></P>
</DIV>
</BODY>
</HTML>